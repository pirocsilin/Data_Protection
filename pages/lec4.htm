<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="do.sibsutis.ru">

  <title>Лекция 4. Конспект лекций</title>
	
	<link rel="icon" type="image/png" href="../lib/css/favicon.png">
  <!-- Bootstrap Core CSS -->
  <link href="../lib/css/bootstrap.css" rel="stylesheet">
	
  <!-- Custom CSS -->
  <link href="../lib/css/scrolling-nav.css" rel="stylesheet">

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
  <![endif]-->
</head>

<!-- The #page-top ID is part of the scrolling feature - the data-spy and data-target are part of the built-in Bootstrap scrollspy function -->

<body id="page-top" data-spy="scroll" data-target=".navbar-fixed-top">
  <!-- Navigation -->
<nav class="navbar navbar-default navbar-fixed-top">
 <div class="container">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
   <li class="hidden"> <a class="page-scroll" href="#page-top"></a> </li>
	 
	 <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
   </button>
	 
   <a class="navbar-brand " href="../index.htm"> 
  <text class = "hidden-xs">Защита информации</text> 
  <text class = "visible-xs">ЗИ</text>
	 </a>
  </div>

  <!-- Collect the nav links, forms, and glyphicon glyphicon-list-alt content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
   
	 <!-- <ul class="nav navbar-nav">
		<li><a href="#"></a></li> 
   </ul> -->
	
   <ul class="nav navbar-nav navbar-right">
    <li class="dropdown">
		<button type="button" class="navbar-toggle dropdown-toggle hidden-xs" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
		</button>	   
		<a class = "dropdown-toggle visible-xs" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Материалы</a>
     <ul class="dropdown-menu">
    <li><a href="../index.htm">Аннотация курса</a></li>
      <li role="separator" class="divider"></li>
  
 <li><a href="lec_index.htm">Теория</a></li>
   
 <li><a href="c_work.htm">Контрольная работа</a></li>
 
<li><a href="labs.htm">Лабораторные работы</a></li> 
      <li role="separator" class="divider"></li>
    
      <li><a href="lit.htm">Литература</a></li>
      <!--li><a href="q.htm">Вопросы для самопроверки</a></li-->			
     </ul>
 </li>
 </ul>
  </div><!-- /.navbar-collapse -->
 </div><!-- /.container-fluid -->
</nav>


  <div id="intro" class="section content-section ">
    <div class="container">
       <div class="row">
        <div class="col-lg-12">	


<!-- содержание -->	
<div class="page-header">				
<h3>4.Современные шифры с секретным ключом</h3>

<a href="#1" class=punkt>4.1. Введение</a><br>
<a href="#2" class=punkt>4.2. Блоковые шифры</a><br> 
<a href="#3" class=punkt>4.3. Основные режимы функционирования блоковых шифров</a><br>
<a href="#4" class=punkt>4.4. Потоковые шифры</a><br>
<a href="#5" class=punkt>4.5. Криптографические хеш-функции</a><br>

</div>
<!--начало-->
<a name=1 class="anchor"></a>
<h3>4.1. Введение</h3>
<p>В этой главе мы рассмотрим вычислительно стойкие шифры с секретным ключом, которые, в принципе, могут быть вскрыты, но требуют для этого очень большого количества вычислений, скажем, 10<sup>20</sup> лет для суперкомпьютера. Эти шифры обеспечивают шифрование и дешифрование данных со скоростями, значительно превышающими скорости шифров с открытыми ключами и стойких шифров, что и объясняет их широкое практическое использование. В последующих разделах мы опишем некоторые наиболее популярные шифры и режимы их функционирования, однако вначале, чтобы пояснить принципы построения этих шифров, продолжим пример с шифром Цезаря, начатый в первой главе.</p>
<p>Там мы рассмотрели атаку по шифротексту на шифр Цезаря. Было показано, что в случае избыточных сообщений шифр легко вскрывается путем перебора ключей. Поищем возможности повышeния стойкости шифра Цезаря. Пожалуй, самое простое, что приходит в голову — увеличить количество возможных значений ключа. В этом случае Еве придется перебирать больше ключей, прежде чем она найдет единственный правильный.</p>
<p>Естественный способ увеличить количество возможных значений ключа для шифра Цезаря — использовать разные ключи для разных букв сообщения. Например, мы можем шифровать каждую нечетную букву ключом <i>k<sub>1</sub></i>, а четную ключом <i>k<sub>2</sub></i>. Тогда секретный ключ <i>k = (k<sub>1</sub>, k<sub>2</sub>)</i> будет состоять из двух чисел, и количество возможных 
ключей будет 32<sup>2</sup> = 1024. Зашифруем наше прежнее сообщение из первой главы ключом <i>k</i> = (3,5):
</p><p><img src="img/image460.png" height="35" width="270">              (4.1)</p>
<p>Эта схема легко обобщается на произвольную длину секретного ключа <i>k = (k<sub>1</sub>, k<sub>2</sub>, . . . , k<sub>t</sub>)<sub>32</sub></i>. При t порядка 10 и выше задача полного перебора ключей становится практически нерешаемой.</p>
<p>Тем не менее, данный шифр легко вскрывается путем так называемого частотного криптоанализа. Для этого используется статистика языка, на котором написано передаваемое сообщение. При использовании частотного криптоанализа перебор начинают с ключей, соответствующих наиболее часто встречающимся буквам и их сочетаниям. Например, известно, что в типичном тексте на русском языке буква О встречается чаще других. Смотрим на ТКУКПКРЕ в (4.1) и определяем, какие буквы встречаются чаще других на четных и нечетных местах. На четных местах это К. Предполагаем, что это код О, следовательно, <i>k<sub>2</sub> = К — О = 28 (mod 32)</i>. На нечетных местах все буквы различны, поэтому для поиска <i>k<sub>1</sub></i> знание частот букв языка не помогает (дело в том, что для нашего примера взято очень короткое сообщение). Пытаемся, как и прежде, найти <i>k<sub>1</sub></i> путем перебора, но убеждаемся, что приемлемых расшифровок не получается. Это означает, что наша гипотеза о том, что О заменяется в шифре на К, неверна. Берем вместо О другую часто встречающуюся букву — букву Е. Вычисляем <i>k<sub>2</sub> = К — Е = 5</i>. Повторяем аналогичные действия для поиска <i>k<sub>1</sub></i> и на этот раз находим решение <i>k<sub>1</sub></i> = 3. В результате, чтобы расшифровать сообщение, из всех возможных 1024 ключей нам понадобилось проверить только 36 (мы проверяли (0,28),...,(31,28),(0,5),...,(3,5)).</p>
<p>Попробуем слегка усложнить шифр, чтобы затруднить частотный криптоанализ. Нам нужно каким-то образом перемешать символы сообщения, заставить их влиять друг на друга, чтобы скрыть ивдивидуальные частоты их появления. По-прежнему будем использовать ключ <i>k = (k<sub>1</sub>, k<sub>2</sub>)</i> и шифровать сообщение блоками по два символа <i>m<sub>i</sub>, m<sub>i+1</sub></i>. Один из простейших вариантов шифра может выглядеть так:</p>
<p><img src="img/image461.png" height="92" width="264">              (4.2)</p>
<p>(все суммы вычисляются по модулю 32). Здесь <i>m<sub>i</sub></i> — нечетная буква исходного текста, <i>m<sub>i+1</sub></i> — четная буква, <i>k<sub>1</sub>, k<sub>2</sub></i> — символы ключа, а <i>C<sub>i</sub>, c<sub>i+1</sub></i> — получаемые символы шифротекста. Например, пара символов ПЕ шифруется ключом <i>k</i> = (3, 5) следующим образом:</p>
<p><img src="img/image462.png" height="95" width="198"></p>
<p>т.е. ПЕ превращается в ЧЮ.</p>
<p>Отметим, что этот шифр можно дешифровать. Алгоритм дешифрования, называемый обычно обратаым шифром, выглядит следующим образом:</p>
<p><img src="img/image463.png" height="96" width="286">              (4.3)</p>
<p>Применяя к нашему сообщению шифр (4.2) с ключом (3, 5), получаем</p>
<p><img src="img/image464.png" height="34" width="421">              (4.4)</p>
<p>Здесь для наглядности после первой стрелки показан промежуточный результат, получающийся после выполнения первых двух операций в (4.2) (это «перемешанный», но еще не зашифрованный текст сообщения). Мы видим, что данный шифр скрывает частоты появления отдельных символов, затрудняя частотный анализ. Конечно, он сохраняет частоты появления пар символов, но мы можем скрыть и их, если будем шифровать сообщения блоками по три символа и т.д.</p>
<p>Вообще, шифр (4.2) выглядит более сложным для Евы по сравнению с шифром (4.1), и он дает нам возможность рассмотреть еще одну ситуацию, связанную с ее действиями. До сих пор мы рассматривали атаки только по шифротексту. что произойдет, если Ева каким-то образом достала открытый текст, соответствующий ранее переданному зашифрованному сообщению? (Т.е. мы находимся в условиях атаки второго типа, см. главу 1, стр. 10.) Например, Ева имеет пару (ПЕРЕМЕНА, ТКУКПКРЕ) для шифра (4.1). Тогда она сразу вычисляет секретный ключ, <i>k<sub>1</sub></i> = Т — П = 3, <i>k<sub>2</sub></i> = К — Е = 5 ,и легко расшифровывает все последующие сообщения от Алисы к Бобу. При использовании шифра (4.2) пара (ПЕРЕМЕНА, ЧЮШЯФЫРТ) уже не дает такого очевидного решения, хотя и здесь оно довольно просто. Ева применяет две первые операции из (4.2) не требующие секретного ключа) к слову ПЕРЕМЕНА, получает промежуточный результат ФЩХЪСЦНН и уже по паре (ФЩХЪСЦНН, ЧЮШЯФЫРТ), как и в первом случае, находит ключ k = 3,5.</p>
<p>Как затруднить такие действия Евы? Идея проста. Будем при шифровании сообщения использовать шифр (4.2) два раза. Тогда получим:</p>
<p><img src="img/image465.png" height="31" width="442">              (4.5)</p>
<p>Теперь, имея пару (ПЕРЕМЕНА, ШШЪЫТПЕЩ), Ева не может вычислить ключ, по крайней мере алгоритм ее действий не очевиден (она не может получить промежуточное значение ЧЮШЯФЫРТ, так как при его построении был использован секретный ключ, ей не известный).</p>
<p>В представленной схеме (4.5) отдельная реализация алгоритма (4.2) называется <i>раундом</i> или <i>циклом</i> шифра.</p>
<p>Мы проиллюстрировали влияние на стойкость шифра таких параметров, как длина ключа, размер блока, количество раундов, а также показали необходимость введения «перемешивающих» преобразований. В реальных шифрах используются, в принципе, те же преобразования, но над более длинными цепочками символов и обладающие целым рядом дополнительных свойств. Это связано с наличием развитых методов криптоанализа, таких, как дифференциальный и линейный криптоанализ, описание которых выходит за рамки нашей книги, но может быть найдено в [27].</p>
<br>
<a name=2 class="anchor"></a>
<h3>4.2. Блоковые шифры</h3>
<p>Блоковый шифр можно определить как зависящее от ключа <i>K</i> обратимое преобразование слова <i>X</i> из n двоичных символов. Преобразованное с помощью шифра слово (или блок) будем обозначать через <i>Y</i>. Для всех рассматриваемых в этом разделе шифров длина слова <i>Y</i> равна длине слова <i>X</i>.</p>
<p>Таким образом, блоковый шифр — это обратимая функция <i>E</i> (другим словами, такая, для которой существует обратная функция). Конкретный вид <i>E<sub>K</sub></i> этой функции определяется ключом <i>K</i>,</p>
<p><img src="img/image466.png" height="51" width="253"></p>
<p>Здесь <img src="img/image467.png" height="28" width="34"> обозначает дешифрующее преобразование и называется <i>обратным шифром</i>.</p>
<p>Для криптографических приложений блоковый шифр должен удовлетворять ряду требований, зависящих от ситуации, в которой он используется. В большинстве случаев достаточно потребовать, чтобы шифр был стоек по отношению к атаке по выбранному тексту. Это автоматически подразумевает его стойкость по отношению к атакам по шифротексту и по известному тексту. Следует заметить, что при атаке по выбранному тексту шифр всегда может быть взломан путем перебора ключей. Поэтому требование стойкости шифра можно уточнить следующим образом.</p>
<p>Шифр <i>стоек</i> (при атаке по выбранному тексту), если для него <i>не существуют</i> алгоритмы взлома, существенно более быстрые, чем прямой перебор ключей.</p>
<p>Нам будет достаточно такого нестрогого определения стойкости. На самом деле, по состоянию на сегодняшний день, ни для одного используемого шифра не доказано соответствие этому определению стойкости. Реально можно говорить о следующем.</p>
<p>Шифр <i>считается стойким</i> (при атаке по выбранному тексту), если для него <i>неизвестны</i> алгоритмы взлома, существенно более эффективные, чем прямой перебор ключей.</p>
<p>Ниже мы приведем примеры некоторых практичеки используемых блоковых шифров. Наша задача будет состоять не только в том, чтобы дать достаточно подробное описание алгоритмов (их описание может быть найдено в литературе), но и в объяснении основных принципов построения блоковых шифров. Кроме того, наше описание может облегчить понимание материала, изложенного в официальных документах (ГОСТах и.т.п.). Далее, на протяжении всей главы, мы будем изучать технику использования блоковых шифров для решения различных задач криптографии.</p>
<p>До недавнего времени ни одна книга по криптографии не обходилась без описания шифра DES (Data Encryption Standard). Этот шифр был принят в качестве стандарта США в 1977 году. Его основные параметры: размер блока 64 бита, длина ключа 56 бит, 16 раундов. Этот шифр интенсивно использовался более двух десятков лет и еще сегодня встречается во многих работающих системах. Несмотря на многочисленные атаки против DES, он так и не был взломан. Однако высокий уровень развития вычислительных средств позволяет сегодня вскрывать DES путем перебора ключей. Напримeр, еще в 1993 году было опубликовано техническое описание системы стоимостью в один миллион долларов, позволяющей взламывать любой ключ DES за 7 часов. В результате DES нe рекомендуется использовать во вновь создаваемых криптографических системах, и поэтому мы нe описываем этот шифр. В 2001 году после специально объявленного конкурса в США был принят новый стандарт на блоковый шифр, названный AES (Advanced Encryption Standard), в основу которого был положeн шифр Rijndael, разработанный бельгийскими специалистами.</p>
<p>Большинство современных блоковых шифров строятся по схемам, значитeльно отличающимся от DES. Тем нe мeнee есть один действующий шифр, построенный на тех же принципах, что и DES, и представляющий для нас особый интерес. Это российский блоковый шифр ГОСТ 28147-89.</p>
<p><b><i>Шифр ГОСТ 28147-89</i></b></p>
<p>Шифр ГОСТ 28147-89 [5], как следует из его обозначeния, был принят в качестве стандарта в 1989 году. Основные параметры ГОСТ 28147-89: длина ключа 256 бит, размер блока 64 бита, 32 раунда. ГОСТ 28147-89 более удобeн для программной реализации, чем DES, имеются сведения о выигрыше по времени примерно в 1.5 раза. В отличие от DES, ГОСТ 28147-89, по-видимому, нe был предметом столь глубокого анализа со стороны мирового криптологического сообщества. Тем нe мeнee, как отмечают специалисты, консервативный дизайн и величина основных параметров (длина ключа, размер блока, количество раундов) позволяют утверждать, что шифр вряд ли может быть слабым. Никаких эффективных атак против шифра ГОСТ 28147-89 нe опубликовано.</p>
<p>В основе ГОСТ 28147-89, так же как и DES, лежит так называeмая структура Фейстела. Блок разбивается на две однаковые части, правую R и левую L. Правая часть объединяется с ключевым элементом и посредством некоторого алгоритма шифрует левую часть. Перед следующим раундом левая и правая части меняются местами. Такая структура позволяет использовать один и тот же алгоритм как для шифрования, так и для дешифрования блока. Это особенно важно при аппаратной реализации, так как прямой и обратный шифры формируются одним и тем же устройством (различается только порядок подачи элементов ключа).</p>
<p>Перейдем к непосредственному описанию шифра ГОСТ 28147-89. Введем необходимые определения и обозначения. Последовательность из 32 бит будем называть словом. Блок текста <i>X</i> (64 бита), также как блок шифротекста <i>Y</i>, состоит из двух слов — левого L и правого R, причем L — старшее слово, а R — младшее. Секретный ключ <i>К</i> (256 бит) рассматривается состоящим из восьми слов <i>К = К<sub>0</sub>К<sub>1</sub> . . . К<sub>7</sub></i>. На его основе строится так называемый раундовый ключ <i>W = W<sub>0</sub>W<sub>1</sub> . . . W<sub>31</sub></i>, состоящий из 32 слов (метод построения раундового ключа будет дан позже).</p>
<p>Для работы шифра нужны 8 таблиц <i>S<sub>0</sub>, S<sub>1</sub>, ..., S<sub>7</sub></i> Называемых также <i>S</i>-боксами). Каждая таблица содержит 16 четырехбитовых элементов, нумеруемых с 0 по 15. Будем обозначать через <i>S<sub>i</sub>[j] j</i> -й элемент <i>i</i> -й таблицы. ГОСТ рекомендует заполнять каждую таблицу различными числами из множества {0,1,..., 15}, переставленными случайным образом. Содержимое таблиц формирует дополнительный секретный параметр шифра, общий для большой группы пользователей. Заметим, что в DES аналогичные S-боксы фиксированы и несекретны.</p>
<p>В шифре используются следующие операции:</p>
<p>+ сложение слов по модулю 2<sup>32</sup>;</p>
<p><img src="img/image468.png" height="10" width="26"> циклический сдвиг слова влево на указанное число бит;</p>
<p><img src="img/image469.png" height="18" width="20"> побитовое «исключающее или» двух слов, т.е. побитовое сложение по модулю 2.</p>
<p><b>Алгоритм 4.1.</b> БАЗОВЫЙ ЦИКЛ ШИФРА ГОСТ 28147-89</p>
<p>ВХОД:	Блок L, R, раундовый ключ W.</p>
<p>ВЫХОД:	Преобразованный блок L, R.</p>
<p><img src="img/image470.png" height="156" width="370"></p>
<p>(На шаге 4 алгоритма используются отдельные четырехбитовые элементы переменной k.)</p>
<p>С помощью базового цикла осуществляется шифрование и дешифрование блока. Чтобы зашифровать блок, строим раундовый ключ</p>
<p><img src="img/image471.png" height="62" width="493">              (4.6)</p>
<p>подаем на вход <i>X</i> и на выходе получаем <i>Y</i>.</p>
<p>Чтобы дешифровать блок, строим раундовый ключ</p>
<p><img src="img/image472.png" height="59" width="493">              (4.7)</p>
<p>подаем на вход <i>Y</i> и на выходе получаем <i>X</i>.</p>
<p>Программная реализация обычно требует переработки цикла 3
алгоритма 4.1, так как работа с полубайтами неэффективна. Ясно, что то же самое преобразование может быть выполнено с использованием четырех таблиц по 256 байт или двух таблиц по 65536 полуслов. Например, при работе с байтами имеем <i>k = (k<sub>3</sub> . . .k<sub>0</sub> )<sub>256</sub></i>, и шаги 3—4 алгоритма 4.1 переписываются следующим образом: </p>
<p><img src="img/image473.png" height="50" width="297"></p>
<p>Таблицы <i>T<sub>j</sub></i>, <i>j</i> = 0,1, 2, 3, вычисляются предварительно из <i>S</i>- боксов:</p>
<p><img src="img/image474.png" height="53" width="391"></p>
<p>ГОСТ ничего не говорит о правилах формирования ключевой информации, кроме требования, чтобы каждый <i>S</i>-бокс содержал перестановку различных чисел. В то же время ясно, что, например, левой ключ или тривиально заданные <i>S</i>-боксы (отображающие k в себя) не обеспечивают секретности шифра.</p>
<br><a name=3 class="anchor"></a>
<h3>4.3. Основные режимы функционирования блоковых шифров</h3>
<p>Блоковые шифры применяются для решения многих задач криптографии. В этом разделе мы рассмотрим основные режимы их использования.</p>
<p>В предыдущем разделе были даны примеры реальных блоковых шифров. Теперь мы можем думать о (идеализированном) блоковом шифре, как о преобразовании входного блока <i>X</i> в выходной блок <i>Y</i> с участием секретного ключа <i>K</i>,</p>
<p><img src="img/image475.png" height="35" width="127"></p>
<p>причем это преобразование должно иметь следующие свойства:</p>
<p class=punkt>1) при известном <i>Y</i>, но неизвестном <i>K</i> практически невозможно узнать <i>X</i>;</p>
<p class=punkt>2) при произвольных известных <i>X</i> и <i>Y</i>, но неизвестном <i>K</i> практически невозможно узнать <i>K</i>.</p>
<p>Вначале рассмотрим классическую задачу шифрования сообщений при помощи блоковых шифров.</p>
<p><b><i>Режим ECB</i></b></p>
<p>Название режима ECB (Electronic CodeBook) можно перевести как электронная кодовая книга.</p>
<p>Сообщение <i>X</i> разбивается на блоки <i>X = X<sub>1</sub>,X<sub>2</sub>,... ,X<sub>t</sub></i>. Каждый блок шифруется блоковым шифром</p>
<p><img src="img/image476.png" height="29" width="230"></p>
<p>Получаем зашифрованное сообщение <i>Y = Y<sub>1</sub>, Y<sub>2</sub>,..., Y<sub>t</sub></i>. Дешифрование выполняется по правилу</p>
<p><img src="img/image477.png" height="35" width="231"></p>
<p>Нетрудно видеть, что дешифрование сообщения можно производить, выбирая блоки шифротекста в произвольном порядке. Такой режим удобен во многих реальных ситуациях. Например, можно работать с базой данных, хранящейся в зашифрованном виде. Однако при таком использовании одинаковые записи будут зашифрованы одинаково. Говорят, что в режиме ECB шифр сохраняет «образ данных», т.е. некий «рисунок» или шаблон, характерный для данных. Это может дать некоторую информацию противнику. Например, если количество <i>различных</i> записей в базе данных невелико (что нередко случается), то противник может составить словарь шифротекстов и вскрыть базу на основе частотного анализа. Заметим, что ему в этом случае не понадобится вскрывать сам шифр.</p>
<p>Некоторые авторы рекомендуют использовать режим ECB только в случаях, когда размер отдельного элемента данных в сообщении, к которому требуется осуществлять непосредственный (прямой) доступ, меньше размера блока. Остаток блока, свободный от данных, рекомендуется заполнять случайно выбираемыми битами. Тогда даже одинаковые элементы данных будут иметь разные шифротексты. При дешифровании биты заполнения просто отбрасываются.</p>
<p>Если размер элемента данных превышает размер блока, то часто рекомендуют использовать режим CBC.</p>
<p><b><i>Режим CBC</i></b></p>
<p>Название режима CBC (Cipher-Block Chaining) переводится как сцепление блоков шифра.</p>
<p>Зашифрованное сообщение получается по следующему правилу:</p>
<p><img src="img/image478.png" height="30" width="286"></p>
<p>т.е. каждый последующий блок открытого текста предварительно закрывается предыдущим зашифрованным блоком. Слово Y0 должно быть определено заранее и известно при шифровании и дешифровании. Полученное зашифрованное сообщение можно дешифровать следующим образом:</p>
<p><img src="img/image479.png" height="34" width="292"></p>
<p>Мы получаем шифротекст, в котором каждый следующий блок зависит от предыдущих. Данный режим разрушает «образ данных». Даже если все блоки <i>X</i> идентичны, шифротекст будет состоять из различных блоков <i>Y</i>. Этот режим предпочтителен при шифровании сообщений, размер которых превышает размер блока. Однако дешифровать сообщение можно только последовательно, начиная с первого блока.</p>
<br>
<a name=4 class="anchor"></a>
<h3>4.4. Потоковые шифры</h3>
<p>В главе 3 мы рассмотрели шифр Вернама и установили, что он является совершенно секретным, т.е. при его использовании противник, перехвативший зашифрованное сообщение, не получает никакой информации об исходном сообщении. В шифре Вернама зашифрованное сообщение <i>y<ub>1</sub>, y<sub>2</sub>,..., y<sub>k</sub></i> получается из исходного сообщения <i>x<sub>1</sub>, x<sub>2</sub>,..., x<sub>k</sub></i> и ключа <i>z<sub>1</sub>, z<sub>2</sub>,..., z<sub>k</sub></i> при помощи операции шифрования, задаваемой равенством</p>
<p><img src="img/image480.png" height="21" width="261">              (4.8)</p>
<p>Мы видели, что данный шифр совершенен только в том случае, если ключ <i>z<sub>1</sub>, z<sub>2</sub>,..., Z<sub>k</sub></i> образован из независимых и равновероятных символов и используется только один раз. Это приводит к необходимости генерировать случайные последовательности очень большого объема и передавать их по закрытым каналам связи, что весьма затруднительно. Поэтому давно была высказана идея использовать в качестве ключа последовательности не случайные, а порожденные при помощи генераторов псевдослучайных чисел. В этом случае в качестве секретного ключа используется начальное значение или состояние генератора. Однако надо четко осознавать, что в этом случае система уже не будет совершенно секретной. Максимум на что мы можем надеяться, это то, что для раскрытия этой системы потребуется очень много времени например, нужно будет выполнить перебор всех возможных начальных состояний генератора). В качестве возмещения за потерю совершенности мы получаем возможность использовать короткие (обычно несколько сотен бит) секретные ключи, которые значительно проще распределять и хранить (а при использовании систем с открытым ключом их можно и вычислять).</p>
<p><b>Определение 4.1.</b> Шифр, построенный на основе (4.8), где в качестве <i>z<sub>1</sub>, z<sub>2</sub>,..., z<sub>k</sub></i> используется псевдослучайная последовательность, называется <i>потоковым шифром</i> (stream cipher).</p>
<p>Как правило, исходное сообщение и ключевая последовательность представляют собой нeзависимыe потоки бит. Так как шифрующее (и дешифрующее) преобразование для всех потоковых шифров одно и то же, они различаются только способом построeния гeнeраторов псевдослучайных чисел. Действительно, чтобы из шифротекста <i>y<sub>1</sub>, y<sub>2</sub>,..., y<sub>k</sub></i>, полученного по формуле (4.8), восстановить сообщение <i>x<sub>1</sub>, x<sub>2</sub>,..., x<sub>k</sub></i>, нeобходимо сгeнeрировать точно такую же последовательность <i>z<sub>1</sub>, z<sub>2</sub>,..., z<sub>k</sub></i>, что и при шифровании, и использовать для дешифрования формулу</p>
<p><img src="img/image481.png" height="21" width="256">              (4.9)</p>
<p>П р и м е р 4.1. Один из самых простых гeнeраторов псевдослучайных чисел (линейный конгруэнтный гeнeратор) работает по схеме </p>
<p><img src="img/image482.png" height="25" width="223">              (4.10)</p>
<p>где a, b, c — нeкоторыe константы, а <i>z<sub>i+1</sub></i> — очередное псевдослучайное число, вычисляемое по предыдущему <i>z<sub>i</sub></i>. Обязательно задается начальноe значeниe <i>z<sub>0</sub></i>. Возьмем в качестве примера a = 5, b = 12, c = 23, и пусть <i>z<sub>0</sub></i> = 4. Вычислим нeсколько элементов последовательности:</p>
<p><img src="img/image483.png" height="160" width="297"></p>
<p>Полученная последовательность внeшнe выглядит как довольно случайная.</p>
<p>Для использования в криптографических целях гeнeратор должeн удовлетворять следующим основным трeбованиям:</p>
<p class=punkt>1)	период последовательности должен быть очень большой;</p>
<p class=punkt>2)	порождаемая последовательность должна быть «почти» неотличима от действительно случайной, в частности, вычисление числа <i>z<sub>i+1</sub></i> по известным предыдущим элементам последовательность без знания ключа должно быть трудной, практически нерешаемой задачей.</p>
<p>Рассмотренный выше линейный конгруэнтный генератор совершенно не годится для криптографических целей, так как известны простые алгоритмы, позволяющие полностью восстановить параметры генератора всего по нескольким элементам порождаемой им последовательности.</p>
<p>В качестве примеров криптостойких генераторов псевдослучайных чисел мы рассмотрим режимы OFB и CTR блоковых шифров и алгоритм RC4.</p>
<p><b><i>Режим OFB блокового шифра</i></b></p>
<p>Название режима OFB (Output FeedBack) переводится как обратная связь по выходу. В этом режиме блоковый шифр на основе секретного ключа <i>К</i> и некоторого инициализирующего вектора <i>Y<sub>0</sub></i> формирует псевдослучайную последовательность <i>r</i>-битовых чисел <i>z<sub>1</sub>, z<sub>2</sub>,..., z<sub>k</sub></i>, которая может использоваться в (4.8) и (4.9) соответственно для шифрования и дешифрования сообщения. Будем считать, как и ранее, что размер блока шифра равен n бит.</p>
<p>Псевдослучайная последовательность получается по схеме</p>
<p><img src="img/image484.png" height="57" width="315"></p>
<p>(здесь <i>r</i>, <img src="img/image485.png" height="22" width="84">, — параметр метода).</p>
<p>При использовании стойкого блокового шифра можно получить криптостойкий генератор, отвечающий приведенным вьше требованиям. А именно, средняя длина периода псевдослучайной последовательности (при случайно выбранных <i>K</i> и <i>Y<sub>0</sub></i>) составляет примерно <i>r2<sup>n-1</sup></i> бит [23]. Кроме того, псевдослучайная последовательность «непредсказуема» для противника, так как возможность предсказания (вычисления) <i>z<sub>i+1</sub></i> на основе <i>z<sub>1</sub>,..., z<sub>i</sub></i> означала бы нестойкость шифра по отношению к атаке по известному тексту. Предсказание <i>z<sub>i+1</sub></i> становится даже более трудной задачей, чем взлом блокового шифра, если <i>r < n</i> [23].</p>
<p>Обратим внимание на одну особенность, характерную для всех потоковых шифров. Для шифрования каждого отдельного сообщения необходимо использовать разные <i>K</i> и/или <i>Y<sub>0</sub></i>. В противном случае несколько сообщений будут шифроваться с помощью одних и тех же последовательностей <i>z</i>, и такой шифр может быть раскрыт. Поясним суть проблемы. Пусть два сообщения <i>u<sub>1</sub>, u<sub>2</sub>,..., u<sub>k</sub></i> и <i>v<sub>1</sub>, v<sub>2</sub>,..., v<sub>k</sub></i> зашифрованы с помощью одной и той же последовательности <i>z</i>. Тогда шифротексты будут иметь вид</p>
<p><img src="img/image486.png" height="55" width="282"></p>
<p>Сложим оба шифротекста и, с учетом равенства <img src="img/image487.png" height="18" width="58"> = 0, получим последовательность</p>
<p><img src="img/image488.png" height="24" width="246"></p>
<p>Мы получили аналог так называемого «шифра с бегущим ключом», когда один текст шифруется с помощью другого текста, взятого из определенного места определенной книги. Известао, что такой шифр не стоек, хотя использовался в эпоху «донаучной» криптографии [23]. Статистический анализ, основанный на избыточности текстов, позволяет в большинстве случаев достаточно точно восстановить оба сообщения.</p>
<p>Дешифрование сообщений для описанного режима блокового шифра может производиться только с начала, так как невозможно получить произвольный элемент последовательности z, не вычислив предыдущие. В этом смысле режим аналогичен режиму CBC. Преимущество режима OFB заключается в том, что последовательность z может быть сформирована заранее для того, чтобы быстро шифровать или дешифровать сообщения с помощью (4.8), (4.9) в момент их поступления. Это может быть актуально для систем, обрабатывающих данные в реальном масштабе времени.</p>
<p><b><i>Режим CTR блокового шифра</i></b></p>
<p>Название данного режима происходит от слова CounTeR — счетчик. Этот режим очень похож на OFB, но в нем шифруется не предыдущий выход шифра, а просто счетчик, увеличиваемый на каждом шаге на постоянное число (обычно 1). Точнее, схема выглядит следующим образом:</p>
<p><img src="img/image489.png" height="26" width="404"></p>
<p>где r — параметр.</p>
<p>При использовании «идеального» блокового шифра режим CTR обеспечивает те же параметры стойкости, что и OFB. Преимущество режима CTR состоит в том, что любой элемент последовательности <i>z</i> может быть вычислен непосредственно. Это дает возможность шифровать и дешифровать любые фрагменты сообщения независимо друг от друга.</p>
<p><b><i>Алгоритм RC4</i></b></p>
<p>Алгоритм RC4, предложенный Ривестом в 1994 году, относится к классу алгоритмов, разработанных специально для потоковых шифров. Генераторы псевдослучайных чисел, построенные с помощью таких алгоритмов, как правило, значительно быстрее генераторов, основанных на блоковых шифрах.</p>
<p>Алгоритм RC4 работает с n-битовыми словами (обычно n = 8). Все вычисления проводятся по модулю 2<sup>n</sup> (остаток <i>x mod 2<sup>n</sup></i> вычисляется очень быстро путем выделения n младших бит в <i>x</i> с помощью логической операции «и»). RC4 использует L -словный ключ <i>K = K<sub>0</sub>K<sub>1</sub>... K<sub>L-1</sub></i> и генерирует последовательность слов <i>Z = z<sub>1</sub>z<sub>2</sub>z<sub>3</sub> ...</i> , конкретный вид которой определяется ключом <i>K</i>. Состояние генератора задается таблицей <i>S</i> из 2<sup>n</sup> слов и двух переменных <i>i</i> и <i>j</i> .В каждый момент времени таблица <i>S</i> содержит все возможные n-битовые числа в перемешанном виде. Так как каждый элемент таблицы принимает значения в промежутке [0, 2n — 1], то его можно трактовать двояко: либо как число, либо как номер другого элемента в таблице. Секретный ключ задает только начальное перемешивание чисел в таблице, которое формируется с помощью следующего алгоритма:</p>
<p><img src="img/image490.png" height="115" width="321"></p>
<p>После этого генератор готов к работе. Генерация очередного псевдосдучанноно слова <i>z<sub>i</sub></i> осуществляется следующим образом:</p>
<p><img src="img/image491.png" height="118" width="241"></p>
<p>П р и м е р 4.2. Пусть <i>n</i> = 3, <i>K</i> = 25 (<i>L</i> = 2).</p>
<p>Сформируем начальную перестановку чисел в таблице <i>S</i> (все вычисления проводим по модулю 8): </p>
<p><img src="img/image492.png" height="205" width="432"></p>
<p>Теперь вычислим несколько первых элементов псевдослучайной последовательности <i>z</i>: </p> 
<p><img src="img/image493.png" height="143" width="544"></p>
<p>и т.д. Чтобы воспользоваться формулой (4.8) для получения шифра, числа <i>z<sub>i</sub></i> записываем в двоичном виде. В рассмотренном примере каждое число <i>z<sub>i</sub></i> представляется тремя битами, и мы получаем последовательность </p>
<p><img src="img/image494.png" height="30" width="355"></p>
<br>
<a name=5 class="anchor"></a>
<h3>4.5. Криптографические хеш-функции</h3>
<p>Хеш-функции (hash functions) находят широкое применение в криптографии, особенно при построении систем цифровой подписи и различных криптографических протоколов, которые будут рассматриваться в последующих главах. В этом разделе мы сформулируем основные требования к криптографически стойким хеш-функциям и рассмотрим один из способов их вычисления. </p>
<p><b>Определение 4.2.</b> Хеш-функцией называется любая функция </p>
<p><img src="img/image495.png" height="31" width="177"></p>
<p>которая строке (сообщению) <i>x<sub>i</sub>x<sub>2</sub> ... х<sub>n</sub></i> <i>произвольной</i> длины n ставит в соответствие целое число <i>фиксированной</i> длины.</p>
<p> Примером хеш-функции может служить контрольная сумма для сообщения. В этом случае</p>
<p><img src="img/image496.png" height="35" width="375"></p>
<p>где <img src="img/image497.png" height="13" width="17"> размер машинного слова. Длина слова, получаемого как значение этой хеш-функции, составляет <img src="img/image497.png" height="13" width="17"> бит независимо от длины сообщения. Контрольные суммы очень часто используются для обнаружения непреднамеренных ошибок в сообщении (при изменении одного символа контрольная сумма изменится). Однако очень легко внести преднамеренную ошибку в сообщение и сохранить при этом значение контрольной суммы. Если бы такая хеш-функция использовалась, например, при генерации электронной подписи, то было бы очень легко изменить содержание подписанного сообщения. Поэтому рассмотренная хеш-функция не годится для криптографических применений.</p>
<p> Сформулируем основные требования, предъявляемые к криптографическим хеш-функциям. Пусть <i>х</i> некоторая строка (сообщение). Тогда</p>
<p class=punkt>1) для любого заданного <i>х</i> вычисление <i>h(х)</i> должно выполняться относительно быстро;</p>
<p class=punkt>2) при известном <i>y</i> должно быть трудно (практически невозможно) найти <i>х</i>, для которого <i>y</i>=<i>h(х)</i>; 
<p class=punkt>3) при известном сообщении <i>х</i> должно быть трудно найти другое сообщение <img src="img/image498.png" height="23" width="54">, такое, что <img src="img/image499.png" height="27" width="103"> 
<p class=punkt>4) должно быть трудно найти какую-либо пару различны сообщений <i>х</i> и <i>х'</i>, для которых <img src="img/image499.png" height="27" width="103"> </p>
<p>Отметим, что первое требование должно выполняться всегда, в противном случае хеш-функция теряет какое-либо практическое значение. Остальные требования важны для тех или иных приложений. Например, если пароли для входа в систему хранятся в виде значений соответствующих им хеш-функций, то хеш-функция должна удовлетворять второму требованию. В схеме электронной подписи актуально третье требование. Четвертое требование важно в некоторых криптографических протоколах. Заметим, что четвертое требование более сильное, чем третье (т.е. при выполнении четвертого автоматически выполняется и третье).</p>
<p>Разработка хеш-функции, удовлетворяющей всем четырем требованиям задача непростая. В настоящее время предложены и практически используются хеш-функции (например, MD5, SHA-1, RIPEMD-160 и др., см., например, [19, 23]), которые считаются отвечающими перечисленным выше требованиям (хотя это строго не доказано). Описание этих и подобных им функций усложнено в деталях и громоздко. Мы рассмотрим универсальный способ построения хеш-функций на базе блоковых шифров, который представляет практический интерес, хотя получаемые хеш-функции и не являются очень быстро вычислимыми. Именно такой подход использован в российском стандарте на криптографическую хеш-функцию (ГОСТ Р34.11-94 [7]).</p>
<p>Пусть дан блоковый шифр <i>Е</i>, который для заданного блока <i>Х</i> и ключа <i>К</i> формирует шифротекст <i>Y</i>,</p>
<p><img src="img/image500.png" height="26" width="114"></p>
<p>Мы представим два алгоритма, для которых длина слова, получаемого как значение хеш-функции, равна размеру блока в шифре, но отметим, что известны конструкции, позволяющие получать хеш-функции с длинами слов, кратными размеру блока. </p>
<p>В первом алгоритме сообщение вначале представляется в виде последовательности блоков <i>Х<sub>1</sub>, Х<sub>2</sub>, ... , Х<sub>n<sub></i>. Последний блок при необходимости дополняется нулями, иногда в последний блок приписывают длину сообщения в виде двоичного числа. Значение хеш-функции <i>h</i> получается как результат выполнения следующего итерационного процесса: </p>
<p><img src="img/image501.png" height="71" width="223"></p>
<p>В качестве начального значения <i>h</i> можно использовать не нуль, а какое-либо «магическое» число, но это не имеет большого значения. В данном алгоритме значение <i>h</i>, полученное на предыдущей итерации, используется в качестве ключа шифра в следующей итерации. Поэтому неявно полагается, что длина ключа в шифре равна длине блока. Однако, как мы видели при изучении шифра RC6, длина ключа может значительно превышать размер блока (в RC6 при максимальной длине блока 256 бит длина ключа может достигать 255 байт, или 2040 бит). В таких случаях более эффективен другой алгоритм. </p>
<p>В этом алгоритме сообщение вначале представляется в виде последовательности <i>Х<sub>1</sub>, Х<sub>2</sub>, ... , Х<sub>m</sub></i> в которой размер каждого элемента равен длине ключа в шифре. Последний элемент заполняется так же, как и в первом алгоритме. Значение хеш-функции <i>h</i> вычисляется следующим образом:</p>
<p><img src="img/image502.png" height="75" width="219"></p>
<p>Здесь уже элементы сообщения выполняют роль ключей в шифре. </p>
<p>Представленные алгоритмы вычисления хеш-функций удовлетворяют всем четырем требованиям, предъявляемым к криптографическим хеш-функциям, в предположении стойкости используемых блоковых шифров (см. [22, 23]).</p>

<br><br>
<!--конец-->
      
				

				</div>
			</div>
			
      </div>
    </div>
  </div>
	
	<!--Меню навигации по Темам -->	
	<div aria-label="..." class = "nav-menu">
	 <ul class="pager background-transition-slow">
		 <li title="Наверх" style = "margin-right:15px;	"><a class = "glyphicon glyphicon-menu-up page-scroll" href="#page-top"></a></li>
		 <li title="К предыдущей лекции"><a class = "glyphicon glyphicon-menu-left page-scroll" href="lec3.htm"></a></li>
		 <li title="В содержание"><a class = "glyphicon glyphicon-list-alt" href="lec_index.htm"></a></li>
		 <li title="К следующей лекции"><a class = "glyphicon glyphicon-menu-right page-scroll" href="lec5.htm"></a></li>
	 </ul>
	</div>
	<!---->
	
	</div>
  <!-- jQuery -->
  <script src="../lib/js/jquery.js"></script>

  <!-- Bootstrap Core JavaScript -->
  <script src="../lib/js/bootstrap.min.js"></script>

  <!-- Scrolling Nav JavaScript -->
  <script src="../lib/js/jquery.easing.min.js"></script>
  <script src="../lib/js/scrolling-nav.js"></script>

</body>

</html>

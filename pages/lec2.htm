<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="do.sibsutis.ru">

  <title>Лекция 2. Конспект лекций</title>
	
	<link rel="icon" type="image/png" href="../lib/css/favicon.png">
  <!-- Bootstrap Core CSS -->
  <link href="../lib/css/bootstrap.css" rel="stylesheet">
	
  <!-- Custom CSS -->
  <link href="../lib/css/scrolling-nav.css" rel="stylesheet">

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
  <![endif]-->
</head>

<!-- The #page-top ID is part of the scrolling feature - the data-spy and data-target are part of the built-in Bootstrap scrollspy function -->

<body id="page-top" data-spy="scroll" data-target=".navbar-fixed-top">
  <!-- Navigation -->
<nav class="navbar navbar-default navbar-fixed-top">
 <div class="container">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
   <li class="hidden"> <a class="page-scroll" href="#page-top"></a> </li>
	 
	 <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
   </button>
	 
   <a class="navbar-brand " href="../index.htm"> 
  <text class = "hidden-xs">Защита информации</text> 
  <text class = "visible-xs">ЗИ</text>
	 </a>
  </div>

  <!-- Collect the nav links, forms, and glyphicon glyphicon-list-alt content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
   
	 <!-- <ul class="nav navbar-nav">
		<li><a href="#"></a></li> 
   </ul> -->
	
   <ul class="nav navbar-nav navbar-right">
    <li class="dropdown">
		<button type="button" class="navbar-toggle dropdown-toggle hidden-xs" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
		</button>	   
		<a class = "dropdown-toggle visible-xs" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Материалы</a>
     <ul class="dropdown-menu">
    <li><a href="../index.htm">Аннотация курса</a></li>
      <li role="separator" class="divider"></li>
  
 <li><a href="lec_index.htm">Теория</a></li>
   
 <li><a href="c_work.htm">Контрольная работа</a></li>
 
<li><a href="labs.htm">Лабораторные работы</a></li> 
      <li role="separator" class="divider"></li>
    
      <li><a href="lit.htm">Литература</a></li>
      <!--li><a href="q.htm">Вопросы для самопроверки</a></li-->			
     </ul>
 </li>
 </ul>
  </div><!-- /.navbar-collapse -->
 </div><!-- /.container-fluid -->
</nav>


  <div id="intro" class="section content-section ">
    <div class="container">
       <div class="row">
        <div class="col-lg-12">	


<!-- содержание -->	
<div class="page-header">				
<h3>2.Криптосистемы с открытым ключом</a></h3>

<a href="#1" class=punkt>2.1. Предыстория и основные идеи</a><br>
<a href="#2" class=punkt>2.2. Первая система с открытым ключом - система Диффи-Хеллмана</a><br>
<a href="#3" class=punkt>2.3. Элементы теории чисел</a><br>
<a href="#4" class=punkt>2.4. Шифр Шамира</a><br>
<a href="#5" class=punkt>2.5. Шифр Эль-Гамаля</a><br>
<a href="#6" class=punkt>2.6. Односторонняя функция с "лазейкой" и шифр RSA</a><br>
<a href="#7"class=punkt>Задачи и упражнения</a><br>
</div>
<!--начало-->

<a name=1 class="anchor"></a>
<h3>2.1. Предыстория и основные идеи</h3>
<p>Рассмотрим три задачи, решение которых поможет нам лучше понять идеи и методы криптографии с открытым ключом. Все эти задачи имеют важное практическое значение.</p>
<p>Первая задача — хранение паролей в компьютере. Мы знаем, что каждый пользователь в сети имеет свой секретный пароль. При входе в сеть пользователь указывает свое имя (несекретное) и затем вводит пароль. Проблема состоит в следующем: если хранить пароль на диске компьютера, то Ева может прочитать его, а затем использовать для несанкционированного доступа (особенно легко это сделать, если Ева работает системным администратором этой сети). Поэтому необходимо организовать хранение паролей в компьютере так, чтобы такой «взлом» был невозможен.</p>
<p>Вторая задача возникла с появлением радиолокаторов и системы ПВО. При пересечении самолетом границы радиолокатор спрашивает пароль. Если пароль верный, то самолет «свой», в противном случае — «чужой». Здесь возникает такая проблема: так как пароль должен передаваться по открытому канале (воздушной среде), то противник может прослушивать все переговоры и узнавать правильный пароль. Затем «чужой» самолет в случае запроса повторит перехваченный ранее «правильный» пароль в качестве ответа локатору и будет пропущен!</p>
<p>Третья задача похожа на предыдущую и возникает в компьютерных сетях с удаленным доступом, например, при взаимодействии  
банка и клиента. Обычно в началe сеанса банк запрашивает у клиента имя, а затем секретный пароль, но Ева может узнать пароль, так как линия связи открытая.</p>
<p>Сeгодня все эти проблемы решаются с использованием криптографических методов. Решение всех этих задач основано на важном понятии односторонней функции (one-way function).</p>
<p><b>Определение 2.1.</b> Пусть дана функция</p>
<p><img src="img/image07.png" height="26" width="101">              (2.1)</p>
<p>определенная на конeчном множестве <img src="img/image08.png" height="25" width="91">, для которой существует обратная функция</p>
<p><img src="img/image09.png" height="26" width="128">              (2.2)</p>
<p>Функция называeтся <i>односторонней</i>, если вычисление по формуле (2.1) — простая задача, требующая нeмного времени, а вычисление по (2.2) — задача сложная, требующая привлeчeния массы вычислительных ресурсов, напримeр, 10<sup>6</sup>-10<sup>10</sup> лет работы мощного суперкомпьютера.</p>
<p>Данное определение, безусловно, нeформально. Строгое определение односторонней функции может быть найдeно в [22, 23], но для наших целей достаточно и вышеприведенного.</p>
<p>В качестве примера односторонней функции рассмотрим следующую:</p>
<p><img src="img/image10.png" height="28" width="144">              (2.3)</p>
<p>где <i>p</i> — нeкотороe простое число (т.е. такое, которое делится без остатка только на себя и на единицу), а <i>x</i> — целое число из множества <i>{1, 2,... ,р — 1}</i>. Обратная функция обозначаeтся</p>
<p><img src="img/image11.png" height="32" width="165">              (2.4)</p>
<p>и называется дискретным логарифмом.</p>
<p>Для того чтобы обеспечить трудность вычисления по (2.4) при использовании лучших современных компьютеров, в настоящее время используются числа размером более 512 бит. На практике часто применяются и другие односторонние функции, например, так называемые хеш-функции, оперирующие с существенно более короткими числами порядка 60-120 бит (они будут рассмотрены в главе 4).</p>
<p>Сначала мы покажем, что вычисление по (2.3) может быть выполнено достаточно быстро. Начнем с примера вычисления числа <i>a</i><sup>16</sup> mod<i>p</i>. Мы можем записать</p> 
<p><img src="img/image12.png" height="60" width="292"></p>
<p>т.е. значение данной функции вычисляется всего за 4 операции умножения вместо 15 при «наивном» варианте <img src="img/image13.png" height="20" width="79">. На этом основан общий алгоритм.</p>
<p>Для описания алгоритма введем величину <img src="img/image14.png" height="27" width="100"> — целую часть <img src="img/image15.png" height="24" width="53"> (далее все логарифмы будут двоичные, поэтому в дальнейшем мы не будем указывать основание 2). Вычисляем числа ряда </p>
<p><img src="img/image16.png" height="36" width="376">              (2.5)</p>
<p>В ряду (2.5) каждое число получается путем умножения предыдущего числа самого на себя по модулю <i>p</i>. Запишем показатель степени <i>x</i> в двоичной системе счисления:</p>
<p><img src="img/image17.png" height="34" width="207"></p>
<p>Тогда число <img src="img/image18.png" height="23" width="106"> может быть вычислено как
<p><img src="img/image19.png" height="66" width="192">              (2.6)</p>
<p>(все вычисления проводятся по модулю <i>p</i>).</p>
<p>П р и м е р 2.1. Пусть требуется вычислить 3<sup>100</sup> mod 7. Имеем t = [log 100] = 6. Вычисляем числа ряда (2.5):</p>
<p><img src="img/image20.png" height="49" width="253">              (2.7)</p>
<p>Записываем показатель в двоичной системе счисления</p>
<p class=punkt>100 = (1100100)<sub>2</sub></p>
<p>и проводим вычисления по формуле (2.6):</p>
<p><img src="img/image21.png" height="62" width="349">              (2.8)</p>
<p>Нам потребовалось всего 8 операций умножения (6 для вычисления ряда (2.7) и 2 для (2.8)).</p>
<p>В общем случае справедливо следующее</p>
<p><b>Утверждение 2.1 (о сложности вычислений (2.3))</b>. <i>Количество операций умножения при вычислении (2.3) по описатому методу не превосходит 2 log x</i>.</p>
<p>Доказательство. Для вычисления чисел ряда (2.5) требуется <i>t</i> умножений, для вычисления <i>у</i> по (2.6) не более, чем t умножений (см. пример 2.1). Из условия <i>t = [log x]</i>, учитывая, что <i>[log x]</i><img src="img/image22.png" height="17" width="20"><i> log x</i>, делаем вывод о справедливости доказываемого утверждения.</p>
<p><u>Замечание</u>. Как будет показано в дальнейшем, при возведении в степень по модулю <i>p</i> имеет смысл использовать только показатели <i>x < p</i>. В этом случае мы можем сказать, что количество операций умножения при вычислении (2.3) не превосходит <i>2 log p</i>.</p>
<p>Важно отметить, что столь же эффективные алгоритмы вычисления обратной функции (2.4) неизвестны. Так, один из методов вычисления (2.4), называемый «шаг младенца, шаг великана» (см. [12]), требует порядка <img src="img/image23.png" height="25" width="39"> операций. Покажем, что при больших p функция (2.3) действительно односторонняя, если для вычисления обратной функции используется метод «шаг младенца, шаг великана». Получаем следующий результат (табл. 2.1).</p>
<p>Таблица2.1. Количество умножений для
вычисления прямой и обратной функции
</p>
<p><img src="img/image25.png" height="172" width="573"></p><br>
<p>Мы видим, что если использовать модули, состоящие из 50-100 десятичных цифр, то «прямая» функция вычисляется быстро, а обратная практически не вычислима. Рассмотрим, например, суперкомпьютер, который умножает два 90-значных числа за 10<sup>-14</sup> сек. (для современных компьютеров это пока не доступно). Для вычисления (2.3) такому компьютеру потребуется</p>
<p><img src="img/image26.png" height="39" width="329"></p>
<p>а для вычисления (2.4) —</p>
<p><img src="img/image27.png" height="37" width="331"></p>
<p>т.е. более 10<sup>22</sup> лет. Мы видим, что вычисление обратных функций практически невозможно при длине чисел порядка 90 десятичных цифр, и использование параллельных вычислений и компьютерных сетей существенно не меняет ситуацию. В рассмотренном примере мы предполагали, что обратная функция вычисляется за <img src="img/image23.png" height="25" width="39"> операций. В настоящее время известны и более «быстрые» методы вычисления дискретного логарифма, однако общая картина та же — количество требуемых в них операций много больше <i>2 log p</i>. Таким образом, можно утверждать, что функция (2.3) действительно односторонняя, но с оговоркой. Никем не доказано, что обратная функция (2.4) не может быть вычислена столь же быстро, как и «прямая».</p>
<p>Используем одностороннюю функцию (2.3) для решения всех трех задач, описанных в начале данного раздела, не забывая, однако, что точно так же может быть использована и любая другая односторонняя функция.</p>
<p>Начнем с хранения паролей в памяти компьютера. Решение задачи основано на том, что пароли вообще не хранятся! Точнее, при регистрации в сети пользователь набирает свое имя и пароль; пусть, например, его имя — «фрукт», а пароль — «абрикос». Компьютер рассматривает слово «абрикос» как двоичную запись числа <i>x</i> и вычисляет (2.3), где <i>а</i> и <i>p</i> — два несекретные числа, возможно даже, всем известные. После этого в памяти компьютера заводится пара (имя, <i>у</i>), где <i>у</i> вычислено по (2.3) при <i>x</i> = пароль. При всех дальнейших входах этого пользователя после ввода пары («фрукт», «абрикос»), компьютер вычисляет по (2.3) новое значение <i>у</i><sub>нов</sub>  с <i>x</i> = «абрикос» и сравнивает с хранящимся в памяти ранее вычисленным значением <i>у</i>. Если <i>у</i><sub>нов</sub> совпадает с хранящимся в памяти <i>у</i>, соответствующим данному имени, то это законный пользователь. В противном случае это Ева.</p>
<p>Ева могла бы попытаться найти <i>x</i> по <i>у</i>. Однако мы видели, что уже при 90-значных числах для этого потребуется более чем 10<sup>22</sup> лет. Таким образом, представленная система хранения пароля весьма надежна и в настоящее время используется во многих реальных операционных системах.</p>
<p>Рассмотрим решение второй задачи (ПВО и самолет). Можно использовать следующий метод. Каждому «своему» самолету присваивается секретное имя, известное системе ПВО и летчику, точнее, бортовому компьютеру. Пусть, например, одному из самолетов присвоено секретное имя СОКОЛ, и этот самолет приближается к границе 01 февраля 2005 года в 12 час.45 мин. Тогда перед приближением к границе бортовой компьютер самолета формирует слово</p>
<p><img src="img/image28.png" height="53" width="410"></p>
<p>Другими словами, компьютер на самолете и станция ПВО прибавляют к секретному слову сведения о текущем времени и, рассматривая полученное слово как число <i>x</i>, вычисляют <img src="img/image29.png" height="26" width="113">, где <i>а</i> и <i>p</i> не секретны. Затем самолет сообщает число у стащии ПВО. Стащия сравнивает вычисленное ею число у с полученным от само¬лета. Если вычисленное и полученное значения совпали, то самолет признается как «свой».</p>
<p>Противник не может взломать эту систему. Действительно, с одной стороны, он не знает секретного слова СОКОЛ и не может найти его по <i>у</i>, так как вычисление <i>x</i> по <i>у</i> занимает, скажем, 10<sup>22</sup> лет. С другой стороны, он не может просто скопировать <i>у</i> и использовать его в качестве ответа в будущем, так как время пересечения границы никогда не повторяется и последующие значения <i>у</i> будут отличаться от первоначального.</p>
<p>Рассмотренный вариант решения «задачи ПВО» требует точной синхронизации часов в самолете и в локаторе. Эта проблема достаточно легко решается. Например, служба навигации постоянно передает метки времени в открытом виде (время не секретно), и все самолеты и локаторы используют эти метки для синхронизации своих часов. Но есть более тонкие проблемы. Метка времени добавляется в слово <i>x</i> для того, чтобы все вычисляемые значения <i>у</i> были различы и противник не мог их повторно использовать. Однако противник может попытаться мгновенно повторить <i>у</i> в пределах текущей минуты. Как предотвратить эту возможность? Это первый вопрос. Другое затруднение возникает в ситуации, когда самолет посылает число <i>у</i> в конце 45-й минуты, а локатор принимает его в начале 46-й. Мы предоставляем читателю возможность самостоятельно предложить вариант решения этих проблем.</p>
<p>Другой способ решения «задачи ПВО» возможен если мы будем использовать дополнительный открытый канал передачи данных от локатора к самолету. Как и вьше, каждый «свой» самолет и локатор знают секретное слово (типа СОКОЛ), которое не заменяется. Обнаружив цель, локатор посылает ей случайно сгенерированное число <i>а</i> («вызов»). Самолет вычисляет <img src="img/image29.png" height="26" width="113">, где <i>x</i> — секретное слово («СОКОЛ»), и сообщает число <i>у</i> локатору. Локатор воспроизводит те же вычисления и сравнивает вычисленное <i>у</i> и принятое. В этой схеме не нужно синхронизировать часы, но, как и ранее, противник не может повторить число <i>у</i>, так как локатор всякий раз посылает разные вызовы (<i>а</i>). Интересно, что эта задача, по-видимому, была исторически первой, при решении которой использовались односторонние функции.</p>
<p>Третья задача решается совершенно аналогично, и оба рассмотренных метода формирования пароля применимы и используются в реальных сетевых протоколах.</p>
<br>
<a name=2 class="anchor"></a>
<h3>2.2. Первая система с открытым ключом - система Диффи-Хеллмана</h3>
<p>Эта криптосистема была открыта в середине 70-х годов американскими учеными Диффи (Whitfield Diffie) и Хейлманом (Martin Hellman) и привела к настоящей революции в криптографии и ее практических применениях. Это первая система, которая позволяла защищать информацию без использования секретных ключей, передаваемых по защищенным каналам. Для того чтобы продемонстрировать одну из схем примeнeния таких систем, рассмотрим сеть связи с N пользователями, где N — большое число. Пусть мы хотим организовать сeкрeтную связь для каждой пары из них. Если мы будем использовать обычную систему распределения секретных ключей, то каждая пара абонентов должна быть снабжена своим секретным ключом, т.е. всего потребуется <img src="img/image30.png" height="32" width="151"> ключей.</p>
<p>Если абонентов 100, то требуется 5000 ключей, если же абонeнтов 10<sup>4</sup>, то ключей должно быть 5 <span
  style='font-size:8.0pt;line-height:150%'>•</span> 10<sup>7</sup>. Мы видим, что при большом числе абонентов система снабжения их секретными ключами становится очень громоздкой и дорогостоящей.</p>
<p>Диффи и Хеллман решили эту проблему за счет открытого распространeния и вычисления ключей. Перейдем к описанию предложенной ими системы.</p>
<p>Пусть строится система связи для абонентов <i>A, B,C,... ,У</i> каждого абонента есть своя секретная и открытая информация. Для организации этой системы выбирается большое простое число p и некоторое число <i>g, 1 < g < p — 1</i>, такое, что все числа из множества <i>{1, 2, ... , p — 1}</i> могут быть представлены как различные степени <i>g mod p</i> (известны различные подходы для нахождения таких чисел<i> g</i>, один из них будет прeдставлeн ниже). Числа <i>p</i> и <i>g</i> известны всем абонeнтам.</p>
<p>Абоненты выбирают большие числа X<sub>A</sub>,X<sub>B</sub>, X<sub>C</sub>, которые хранят в секрете (обычно такой выбор рекомендуется проводить случайно, используя датчики случайных чисел). Каждый абонент вычисляет соответствующее число Y , которое открыто передается другим абонентам,</p>
<p><img src="img/image31.png" height="82" width="189">              (2.9)</p>
<p>В результате получаем следующую таблицу.</p>
<p>Т а б л и ц а 2.2. Ключи пользователей в системе Диффи-Хеллмана</p>
<p><img src="img/image32.png" height="94" width="426"></p>
<p>Допустим, абонент A решил организовать сеанс связи с B, при этом обоим абонентам доступна открытая информация из табл. 2.2. Абонент A сообщает B по открытому каналу, что он хочет передать ему сообщение. Затем абонент A вычисляет величину</p>
<p><img src="img/image33.png" height="32" width="190">              (2.10)</p>
<p>(никто другой кроме A этого сделать не может, так как число X<sub>A</sub> секретно). В свою очередь, абонент B вычисляет число</p>
<p><img src="img/image34.png" height="35" width="199">              (2.11)</p>
<p><b>Утверждение 2.2.</b> <i>Z<sub>AB</sub> = Z<sub>BA</i></sub>.
<p>Д о к а з а т е л ь с т в о. Действительно,</p>
<p><img src="img/image35.png" height="77" width="553"></p>
<p>(Здесь первое равенство следует из (2.10), второе и четвертое — из (2.9), последнее — из (2.11).)</p>
<p>Отметим главные свойства системы:</p>
<p class=punkt>1)	абоненты A и B получили одно и то же число <i>Z = Z<sub>AB</sub> = Z<sub>BA</sub> </i>, которое не передавалось по открытой линии связи;</p>
<p class=punkt>2)	Ева не знает секретных чисел <i>X<sub>A</sub></i> , <i>X<sub>B</sub></i>,..., поэтому не может
вычислить число <i>Z<sub>AB</sub></i> (вообще говоря, она могла бы попытаться найти секретное число <i>X<sub>A</sub></i> по <i>Y<sub>A</sub></i> (см. (2.9)), однако при больших <i>p</i> это практически невозможно (требуются миллионы лет)).</p>
<p>Абоненты A и B могут использовать <i>Z<sub>AB</sub></i> в качестве секретного ключа для шифрования и дешифрования данных. Таким же образом любая пара абонентов может вычислить секретный ключ, известный только им.</p>
<p>Остановимся теперь на упомянутой выше задаче выбора числа <i>g</i>. При произвольно заданном <i>p</i> она может оказаться трудной задачей, связанной с разложением на простые множители числа <i>p — 1</i>. Дело в том, что для обеспечения высокой стойкости рассмотренной системы число <i>p — 1</i> должно обязательно содержать большой простой множитель (в противном случае алгоритм Полига-Хеллмана, описанный, например, в [23], быстро вычисляет дискретный логарифм). Поэтому часто рекомендуют использовать следующий подход. Простое число <i>p</i> выбирается таким, чтобы выполнялось равенство</p>
<p><img src="img/image36.png" height="32" width="136"></p>
<p>где <i>q</i> — также простое число. Тогда в качестве <i>g</i> можно взять любое число, для которого справедливы неравенства</p>
<p><img src="img/image37.png" height="36" width="285"></p
<p>П р и м е р 2.2. Пусть <i>p =23 = 2 <span
  style='font-size:8.0pt;line-height:150%'>•</span> 11 + 1 (q = 11)</i>. Выберем параметр <i>g</i>. Попробуем взять <i>g = 3</i>. Проверим: <i>311 mod 23 = 1</i> и значит, такое <i>g</i> не подходит. Возьмем <i>g = 5</i>. Проверим: <i>511 mod 23 = 22</i>. Итак, мы выбрали параметры <i>p = 23</i>, <i>g = 5</i>. Теперь каждый абонент выбирает секретное число и вычисляет соответствующее ему открытое число. Пусть выбраны <i>X<sub>A</sub> = 7</i>, <i>X<sub>B</sub> = 13</i>. Вычисляем <i>Y<sub>A</sub> = 57 mod 23 = 17</i>, <i>Y<sub>B</sub> = 513 mod 23 = 21</i>. Пусть <i>A</i> и <i>B</i> решили сформировать общий секретный ключ. Для этого <i>A</i> вычисляет <i>Z<sub>AB</sub> = 217 mod 23 = 10</i>, а <i>B</i> вычисляет <i>Z<sub>BA</sub> = 1713 mod 23 = 10</i>. Теперь они имеют общий ключ 10, который не передавался по каналу связи.</p>
<br>
<a name=3 class="anchor"></a>
<h3>2.3. Элементы теории чисел</h3>
<p>Многие криптографические алгоритмы базируются на результатах классической теории чисел. Мы рассмотрим необходимый минимум из этой теории. Классические теоремы Ферма, Эйлера и ряд других результатов из теории чисел будут даны без доказательств, которые могут быть найдены практически в любом учебнике по теории чисел (см., например, [3]). Читатели, знакомые с теорией чисел, могут непосредственно перейти к разд. 2.4.</p>
<p><b>Определение 2.2.</b> Целое положительное число <i>p</i> называется простым, если оно не делится ни на какое другое число, кроме самого себя и единицы.</p>
<p>П р и м е р 2.3. Числа 11, 23 — простые; числа 27, 33 — составные (27 делится на 3 и на 9, 33 делится на 3 и на 11).
<p><b>Теорема 2.3 (основная теорема арифметики).</b> <i>Любое целое положительное число может быть представлено в виде произведения простых чисел, причем единственным образом.</i></p>
<p>П р и м е р 2.4. 27 = 3 <span style='font-size:8.0pt;line-height:150%'>•</span> 3 <span style='font-size:8.0pt;line-height:150%'>•</span> 3, 33 = 3 <span style='font-size:8.0pt;line-height:150%'>•</span> 11.</p>
<p><b>Определение 2.3.</b> Два числа называются взаимно простыми, если они не имеют ни одного общего делителя кроме единицы.</p>
<p>П р и м е р 2.5. Числа 27 и 28 взаимно просты (у них нет общих делителей кроме единицы), числа 27 и 33 — нет (у них есть общий делитель 3).</p>
<p><b>Определение 2.4 (функция Эйлера).</b> Пусть дано целое число <img src="img/image38.png" height="26" width="66">. Значение <i>функции Эйлера</i> <img src="img/image39.png" height="25" width="53"> равно количеству чисел в ряду 1, 2, 3,..., N — 1, взаимно простых с N.</p>
<p>П р и м е р 2.6.</p>
<p><img src="img/image40.png" height="81" width="518"></p>
<p>(здесь зачеркнуты числа, не взаимнопростые с аргументом).</p>
<p><b>Утверждение 2.4.</b> Если <i>p</i> — простое число, то <img src="img/image41.png" height="23" width="112"></p>
<p>Доказательство. В ряду 1, 2, 3,... ,<i>p — 1</i> все числа взаимно просты с <i>p</i>, так как <i>p</i> — простое число и по определению не делится ни на какое другое число.</p>
<p><b>Утверждение 2.5.</b> Пусть <i>p</i> и <i>q</i> — <i>два различных простых числа </i><img src="img/image42.png" height="22" width="63">. Тогда <img src="img/image43.png" height="25" width="185">.</p>
<p>Доказательство. В ряду 1, 2,... ,<i>pq — 1</i> не взаимнопростыми с <i>pq</i> будут числа</p>
<p><img src="img/image44.png" height="32" width="211"></p>
<p>и</p>
<p><img src="img/image45.png" height="32" width="204"></p>
<p>Всего таких чисел будет <i>(q — 1) + (p — 1)</i>. Следвательто, количество чисел, взаимнопростых с <i>pq</i>, будет <i>pq — 1 — (p — 1) — (q — 1) = pq — q — p + 1 = (p — 1) (q — 1)</i>.</p>
<p><b>Теорема 2.6 (Ферма).</b> Пусть <i>p</i> — простое число и <i>0 < a < p</i>. Тогда</p>
<p><img src="img/image46.png" height="31" width="168"></p>
<p>П р и м е р 2.7. <i>p = 13, a = 2;</i></p>
<p><img src="img/image47.png" height="100" width="490"></p>
<p><b>Теорема 2.7 (Эйлер).</b> Пусть <i>a</i> и <i>b</i> — взаимно простые числа. Тогда</p>
<p><img src="img/image48.png" height="36" width="155"></p>
<p>Теорема Ферма является частным случаем теоремы Эйлера, когда <i>b</i> — простое число.</p>
<p>П р и м е р 2.8.</p>
<p><img src="img/image49.png" height="151" width="446"></p>
<p>Нам понадобится еще одна теорема, близкая к теореме Эйлера.</p>
<p><b>Теорема 2.8.</b> Если <i>p</i> и <i>q</i> — простые числа, <i>p = q</i> и <i>к</i> — произвольное целое число, то</p>
<p><img src="img/image50.png" height="34" width="208">              (2.12)</p>
<p>П р и м е р 2.9. Возьмем <i>p = 5, q = 7</i>. Тогда <i>pq = 35</i>, а функция Эйлера — <img src="img/image51.png" height="23" width="155">. Рассмотрим случай <i>к = 2</i>, т.е. будем возводить числа в степень 2 <span style='font-size:8.0pt;line-height:150%'>•</span> 24 + 1 = 49. Получим</p>
<p><img src="img/image52.png" height="28" width="308"></p>
<p>Это не удивительно, так как каждое из чисел 9 и 23 взаимно просто с модулем 35, и по теореме Эйлера 924 mod 35 = 1, 2324 mod 35 = 1. Однако теорема 2.8 остается верной и для следующих чисел:
<p><img src="img/image53.png" height="35" width="336"></p>
<p>в то время как теорема Эйлера для них не применима (каждое из чисел 10 и 28 не взаимно просто с модулем 35 и 1024 mod 35 = 15, 2824 mod 35 = 21).</p>
<p><b>Определение 2.5.</b> Пусть <i>а</i> и <i>b</i> — два целых положительных числа. Наибольший общий делитель чисел <i>а</i> и <i>b</i> есть наибольшее число <i>c</i>, которое делит и <i>а</i> и <i>b</i>:</p>
<p><img src="img/image54.png" height="26" width="148"></p>
<p>(Обозначение <i>gcd</i> для наибольшего общего делителя происходит от английских слов greatest common divisor и принято в современной литературе.)</p>
<p>П р и м е р 2.10. <i>gcd(10,15) = 5; gcd(8, 28) = 4</i>.</p>
<p>Для нахождения наибольшего общего делителя можно использовать следующий алгоритм, известный как алгоритм Евклида.</p>
<p><b>Алгоритм 2.1.</b> АЛГОРИТМ ЕВКЛИДА</p>
<p>ВХОД:       Положительные целые числа a, b,  a <img src="img/image55.png" height="19" width="21"> b.</p>
<p>ВЫХОД:	Наибольший общий делитель gcd(a, b).
<p><img src="img/image56.png" height="69" width="331"></p>
<br>
<p>П р и м е р 2.11. Покажем, как с помощью алгоритма Евклида вычисляется gcd(28, 8):</p>
<p><img src="img/image57.png" height="72" width="162"></p>
<p>Здесь каждый столбец представляет собой очередную итерацию алгоритма. Процесс продолжается до тех пор, пока b не станет равным нулю. Тогда в значении переменной a содержится ответ (4).</p>
<p>Для многих криптографических систем, рассматриваемых в следующих разделах и главах, актуален так называемый обобщенный алгоритм Евклида, с которым связана следующая теорема.</p>
<p><b>Теорема 2.9.</b> <i>Пусть a  и  b  — два целых положительных числа. Тогда существуют целые (нe обязательно положительные) числа  x  и  y  , такие, что</i></p>
<p><img src="img/image58.png" height="27" width="182">              (2.13)</p>
<p>Обобщенный алгоритм Евклида служит для отыскания gcd(a, b) и x, y, удовлетворяющих (2.13). Введем три строки U = (u<sub>1</sub>, u<sub>2</sub>, u<sub>3</sub>), V = (v<sub>1</sub>, v<sub>2</sub>, v<sub>3</sub>) и T = (t<sub>1</sub>, t<sub>2</sub>, t<sub>3</sub>). Тогда алгоритм записывается следующим образом. </p>
<p><b>Алгоритм 2.2.</b> ОБОБЩЕННЫЙ АЛГОРИТМ ЕВКЛИДА</p>
<p>ВХОД:       Положительные целые числа a,b, a > b.</p>
<p>ВЫХОД:       gcd(a, b), x, y, удовлетворяющие (2.13).</p>
<p><img src="img/image59.png" height="140" width="416"></p>
<br><p>Результат содержится в строке U.</p>
<p>Операция div в алгоритме — это целочисленное деление</p>
<p><img src="img/image60.png" height="31" width="169"></p>
<p>Доказательство корректности алгоритма 2.2 может быть найдeно в [1, 9].</p>
<p>П р и м е р 2.12. Пусть a=28, b=19. найдeм числа x и у, удовлетворяющие (2.13).
<p><img src="img/image61.png" height="125" width="341"></p>
<p>Поясним представленную схему. Вначалe в строку U записываются числа (28,1,0), а в строку V — числа (19,0,1) (это первые две строки на схеме). Вычисляется строка T (третья строка в схеме). После этого в качестве строки U берется вторая строка в схеме, а в качестве V — третья, и опять вычисляется строка T (четвертая строка в схеме).</p>
<p>Этот процесс продолжается до тех пор, пока первый элемент строки V не станет равным нулю. Тогда предпоследняя строка в схеме содержит ответ. В нашем случае gcd(28,19) = 1, x = —2, у = 3. Выполним проверку: 28 <span style='font-size:8.0pt;line-height:150%'>•</span> (—2)+ 19 <span style='font-size:8.0pt;line-height:150%'>•</span> 3=1.</p>
<p>Рассмотрим одно важное применение обобщенного алгоритма Евклида. Во многих задачах криптографии для заданных чисел c, m требуется находить такое число <i>d < m</i>, что</p>
<p><img src="img/image62.png" height="27" width="144">              (2.14)</p>
<p>Отметим, что такое <i>d</i> существует тогда и только тогда, когда числа <i>c</i> и <i>m</i> взаимно простые.</p>
<p><b>Определение 2.6.</b> Число d, удовлетворяющее (2.14), называется <i>инверсией c по модулю m</i> и часто обозначается <i>c<sup>-1</sup> mod m</i>.</p>
<p>Данное обозначение для инверсии довольно естественно, так как мы можем теперь переписать (2.14) в виде</p>
<p><img src="img/image63.png" height="30" width="162"></p>
<p>Умножение на c<sup>-1</sup> соответствует делению на c при вычислениях по модулю m. По аналогии можно ввести произвольные отрицательные степени при вычислениях по модулю m:</p>
<p><img src="img/image64.png" height="31" width="281"></p>
<p>П р и м е р 2.13.  3 <span style='font-size:8.0pt;line-height:150%'>•</span> 4 mod 11 = 1, поэтому число 4 — это инверсия числа 3 по модулю 11. Можно записать 3<sup>-1</sup> mod 11 = 4. Число 5<sup>-2</sup> mod 11 может быть найдено двумя способами:</p>
<p><img src="img/image65.png" height="74" width="484"></p>
<p>При вычислениях по второму способу мы использовали равенство 5<sup>-1</sup> mod 11 = 9. Действительно, 5 <span style='font-size:8.0pt;line-height:150%'>•</span> 9 mod 11 = 45 mod 11 = 1.	</p>
<p>Покажем, как можно вычислить инверсию с помощью обобщенного алгоритма Евклида. Равенство (2.14) означает, что для некоторого целого k</p>
<p><img src="img/image66.png" height="24" width="136">              (2.15)</p>
<p>Учитывая, что c и m взаимно просты, перепишем (2.15) в виде</p>
<p><img src="img/image67.png" height="27" width="215">              (2.16)</p>

<p>что полностью соответствует (2.13), здесь только по-другому обозначены переменные. Поэтому, чтобы вычислить <i>c<sup>-1</sup> mod m</i>, т.е. найти число d, нужно просто использовать обобщенный алгоритма Евклида для решения уравнения (2.16). Заметим, что значение переменной k нас не интересует, поэтому можно не вычислять вторые элементы строк U , V , T . Кроме того, если число d получается отрицательным, то нужно прибавить к нему m, так как по определению число a mod m берется из множества {0,1,..., m — 1}.</p>
<p>П р и м е р 2.14. Вычислим 7<sup>-1</sup> mod 11. Используем такую же схему записи вычислений, как в примере 2.12 :</p>
<p><img src="img/image68.png" height="138" width="163"></p>
<p>Получаем d = —3 и d mod 11	= 11 — 3 = 8, т.е. 7<sup>-1</sup> mod 11 = 8.</p>
<p>Проверим результат: 7 <span style='font-size:8.0pt;line-height:150%'>•</span> 8 mod 11 = 56 mod 11 = 1.</p>
<p>Одной из важнейших операций в криптографии с открытыми ключами является операция возведения в степень по модулю. Идея построения эффективного алгоритма возведения в степень была ранее
проиллюстрирована с помощью (2.5) и (2.6). Рассмотренный алгоритм можно реализовать и без хранения в памяти ряда чисел (2.5). Дадим описание этого алгоритма в форме, пригодной для непосредственной программной реализации. В названии алгоритма отражен тот факт, что биты показателя степени просматриваются справа-налево, т.е. от младшего к старшему.</p>
<p><b>Алгоритм 2.3.</b> ВОЗВЕДЕНИЕ В СТЕПЕНЬ (СПРАВА-НАЛЕВО)</p>
<p>ВХОД:       Целые числа <i>a, x = (x<sub>t</sub> x<sub>t-1</sub> ... x<sub>0</sub>)<sub>2</sub>, p</i>.</p>
<p>ВЫХОД:       Число<i> y = a<sup>x</sup> mod p</i>.</p> 
<p><img src="img/image69.png" height="120" width="393"></p>
<p>Чтобы показать, что по представленному алгоритму действительно вычисляется <i>y</i> согласно (2.6), запишем степени переменных после
каждой итерации цикла. Пусть x = 100 =	(1100100)<sub>2</sub>, как в примере 2.1, тогда:</p>
<p><img src="img/image70.png" height="95" width="344"></p>
<p>В некоторых ситуациях более эффективным оказывается следующий алгоритм, в котором биты показателя степени просмативаются слева-направо, т.е. от старшего к младшему.</p>
<p><b>Алгоритм 2.4.</b> ВОЗВЕДЕНИЕ В СТЕПЕНЬ (СЛЕВА-НАПРАВО)</p>
<p>ВХОД:       Целые числа <i>a, x = (x<sub>t</sub> x<sub>t-1</sub> ... x<sub>0</sub>)<sub>2</sub>, p</i>.</p>
<p>ВЫХОД:       Число<i> y = a<sup>x</sup> mod p</i>.</p> 
<p><img src="img/image71.png" height="79" width="354"></p>
<p>Приведенных в данном разделе сведений из теории чисел будет достаточно для описания основой криптографических алгоритмов и методов. </p>
<br>
<a name=4 class="anchor"></a>
<h3>2.4. Шифр Шамира</h3>
<p>Этот шифр, предложенный Шамиром (Adi Shamir), был первым, позволяющим организовать обмен секретными сообщениями по открытой линии связи для лиц, которые не имеют никаких защищенных каналов и секретных ключей и, возможно, никогда не видели друг друга. (Напомним, что система Диффи-Хеллмана позволяет сформировать только секретное слово, а передача сообщения потребует использования некоторого шифра, где это слово будет использоваться как ключ.)</p>
<p>Перейдем к описанию системы. Пусть есть два абонента A и B, соединенные линией связи. A хочет передать сообщение m абоненту B так, чтобы никто не узнал его содержание. A выбирает случайное большое простое число p и открыто передает его B. Затем A выбирает два числа c<sub>A</sub> и d<sub>A</sub>, такие, что</p>
<p><img src="img/image72.png" height="31" width="220">              (2.17)</p>
<p>Эти числа A держит в секрете и передавать не будет. B тоже выбирает два числа c<sub>B</sub> и d<sub>B</sub> , такие, что</p>
<p><img src="img/image73.png" height="28" width="212">              (2.18)</p>
<p>и держит их в секрете.</p>
<p>После этого A передает свое сообщение m, используя трехступенчатый протокол. Если m < p (m рассматривается как число), то сообщение m передается сразу , если же m <img src="img/image74.png" height="18" width="21"> p, то сообщение предствляется в виде m<sub>1</sub>, m<sub>2</sub>, . . . , m<sub>t</sub> , где все m<sub>i</sub> < p, и затем передаются последовательно m<sub>1</sub>, m<sub>2</sub>, ... ,m<sub>t</sub>. При этом для кодирования каждого m<sub>i</sub> лучше выбирать случайно новые пары (c<sub>A</sub>, d<sub>A</sub>) и (c<sub>B</sub>,d<sub>B</sub>) — в противном случае надежность системы понижается. В настоящее время такой шифр, как правило, используется для передачи чисел, например, секретных ключей, значения которых меньше p. Таким образом, мы будем рассматривать только случай m < p. Дадим описание протокола.</p>
<p><b>Шаг 1.</b> A вычисляет число</p>
<p><img src="img/image75.png" height="28" width="171">              (2.19)</p>
<p>где m — исходное сообщение, и пересылает х<sub>1</sub> к B.</p>
<p><b>Шаг 2.</b> B, получив х<sub>1</sub>, вычисляет число</p>
<p><img src="img/image76.png" height="34" width="160">              (2.20)</p>
<p>и передает x<sub>2</sub> к A.</p>
<p><b>Шаг 3.</b> A вычисляет число</p>
<p><img src="img/image77.png" height="32" width="172">              (2.21)</p>
<p>и передает его B.</p>
<p><b>Шаг 4.</b> B, получив х<sub>3</sub>, вычисляет число</p>
<p><img src="img/image78.png" height="33" width="152">              (2.22)</p>
<br>
<p><b>Утверждение 2.10 (свойства протокола Шамира).</b></p>
<p>1)	х<sub>4</sub> = m, <i>т.е. в результате реализации протокола от A к B действительно передается исходное сообщение;</i></p>
<p>2)	злоумышленник не может узнать, какое сообщение было передано.</p>
<p>Доказательство. Вначалe заметим, что любое целое число <img src="img/image79.png" height="25" width="62"> может быть представлено в виде <img src="img/image80.png" height="22" width="146">, где <i>r = e mod (p — 1)</i>. </p>
<p>Поэтому на основании теоремы Ферма</p>
<p><img src="img/image81.png" height="72" width="485">              (2.23)</p>
<p>Справедливость первого пункта утверждения вытекает из следующей цепочки равенств:</p>
<p><img src="img/image82.png" height="90" width="508"></p>  
<p>(прeдпослeднee равенство следует из (2.23), а послeднee выполняeтся в силу (2.17) и (2.18)).</p>
<p>Доказательство второго пункта утвeрждeния основано на предположении, что для злоумышленника, пытающегося определить m, нe существует стратегии более эффективной, чем следующая. Вначалe он вычисляет c<sub>B</sub> из (2.20), затем находит d<sub>B</sub> и, наконeц, вычисляет x<sub>4</sub> = m по (2.22). для осущeствлeния этой стратегии злоумышленник должeн решить задачу дискретного логарифмирования (2.20), что практически нeвозможно при больших p.</p>
<p>Опишем метод нахождeния пар c<sub>A</sub>,d<sub>A</sub> и c<sub>B</sub>, d<sub>B</sub>, удовлетворяющих (2.17) и (2.18). Достаточно описать только действия для абонeнта A, так как действия для B совершенно аналогичны. Число C<sub>A</sub> выбираем случайно так, чтобы оно было взаимно простым с p — 1 (поиск целесообразно вести среди нeчeтных чисел, так как p — 1 четно). Затем вычисляем d<sub>A</sub> с помощью обобщенного алгоритма Евклида, как это было объяснено в разд. 2.3.</p>
<p>П р и м е р 2.15. Пусть A хочет передать B сообщение <i>m = 10</i>. A выбирает <i>p = 23</i>, c<sub>A</sub> = 7 (gcd(7, 22) = 1) и вычисляет d<sub>A</sub> = 19.</p>
<p>Аналогично, B выбирает параметры c<sub>B</sub> = 5 (взаимно простое с 22) и d<sub>B</sub> = 9. Переходим к протоколу Шамира.</p>
<p><img src="img/image83.png" height="146" width="275"></p>
<p>Таким образом, B получил передаваемое сообщение m =10.</p>
<br>
<a name=5 class="anchor"></a>
<h3>2.5. Шифр Эль-Гамаля</h3>
<p>Пусть имеются абоненты A, B, C, ..., которые хотят передавать друг другу зашифрованные сообщения, не имея никаких защищенных каналов связи. В этом разделе мы рассмотрим шифр, предложенный Эль-Гамалем (Taher ElGamal), который решает эту задачу, используя, в отличие от Шифра Шамира, только одну пересылку сообщения. Фактически здесь используется схема Диффи-Хеллмана, чтобы сформировать общий секретный ключ для двух абонентов, передающих друг другу сообщение, и затем сообщение шифруется путем умножения его на этот ключ. Для каждого следующего сообщения секретный ключ вычисляется заново. Перейдем к точному описанию метода.</p>
<p>Для всей группы абонентов выбираются некоторое большое простое число p и число g, такие, что различные степени g суть различные числа по модулю p (см. разд. 2.2). Числа p и g передаются абонентам в открытом виде (они могут использоваться всеми абонентами сети).</p>
<p>Затем каждый абонент группы выбирает свое секретное число c<sub>i</sub>, 1 < c<sub>i</sub> < p - 1 , и вычисляет соответствующее ему открытое число d<sub>i</sub>, </p>
<p><img src="img/image84.png" height="28" width="149">              (2.24)</p>
<p>В результате получаем таблицу 2.3.</p>
<br>
<p>Т а б л и ц а 2.3. Ключи пользователей в системе Эль-Гамаля</p>
<p><img src="img/image85.png" height="98" width="450"></p>
<p>Покажем теперь, как A передает сообщение m абоненту B. Будем предполагать, как и при описании шифра Шамира, что сообщение представлено в виде числа <i>m < p</i>.</p>
<p><b>Шаг 1.</b> A формирует случайное число k, 1 < k < p — 2, вычисляет числа</p>
<p><img src="img/image86.png" height="29" width="154">              (2.25)</p>
<p><img src="img/image87.png" height="26" width="169">              (2.26)</p>
<p>и передает пару чисел (r, e) абоненту B.</p>
<p><b>Шаг 2.</b> B, получив (r, e ), вычисляет</p>
<p><img src="img/image88.png" height="31" width="210">              (2.26)</p>
<p><b>Утверждение 2.11 (свойства шифра Эль-Гамаля).</b></p>
<p class=punkt>1)	<i>Абонент B получил сообщение, т.е. m' = m;</i></p>
<p class=punkt>2)	<i>противник, зная p, g, d<sub>B</sub>, r и e, не может вычислить m</i>.</p>

<p>Доказательство. Подставим в (2.27) значение <i>e</i> из (2.26):</p>
<p><img src="img/image89.png" height="37" width="260"></p>
<p>Теперь вместо r подставим (2.25), а вместо d<sub>B</sub> — (2.24):</p>
<p><img src="img/image90.png" height="75" width="544"></p>
<p>По теореме Ферма</p>
<p><img src="img/image91.png" height="46" width="292"></p>
<p>и, таким образом, мы получаем первую часть утверждения.</p>
<p>Для доказательства второй части заметим, что противник не может вычислить k в равенстве (2.25), так как это задача дискретного логарифмирования. Следовательно, он не может вычислить m в равенстве (2.26), так как m было умножено на неизвестное ему число. Противник также не может воспроизвести действия законного получателя сообщения (абонента B), так как ему не известно секретное число c<sub>B</sub> (вычисление c<sub>B</sub> на основании (2.24) — также задача дискретного логарифмирования).</p>
<p>П р и м е р 2.16. Передадим сообщение <i>m = 15</i> от A к B. Выберем параметры аналогично тому, как это было сделано в примере 2.2 стр. 24. Возьмем p = 23, g = 5. Пусть абонент B выбрал для себя секретное число c<sub>B</sub> = 13 и вычислил по (2.24)</p>
<p><img src="img/image92.png" height="30" width="205"></p>
<p>Aбонент A выбирает случайно число k, например k = 7, и вычисляет по (2.25), (2.26):</p>
<p><img src="img/image93.png" height="40" width="531"></p>
<p>Теперь A посылает к B зашифрованное сообщение в виде пары чисел (17, 12). B вычисляет по (2.27)</p>
<p><img src="img/image94.png" height="30" width="544"></p>
<p>Мы видим, что B смог расшифровать переданное сообщение.</p>
<p>Ясно, что по аналогичной схеме могут передавать сообщения все абоненты в сети. Заметим, что любой абонент, знающий открытый ключ абонента B, может посылать ему сообщения, зашифрованные с помощью открытого ключа d<sub>B</sub>. Но только абонент B, и никто другой, может расшифровать эти сообщения, используя известаый только ему секретный ключ c<sub>B</sub>. Отметим также, что объем шифра в два раза превышает объем сообщения, но требуется только одна передача данных (при условии, что таблица с открытыми ключами заранее известна всем абонентам).</p>
<br>
<a name=6 class="anchor"></a>
<h3>2.6. Односторонняя функция с "лазейкой" и шифр RSA</h3>
<p>Названный в честь его разработчиков Ривеста (Ron Rivest), Шамира (Adi Shamir) и Адлемана (Leonard Adleman), этот шифр до сих пор является одним из самых широко используемых.</p>
<p>Мы видели, что шифр Шамира полностью решает задачу обмена сообщениями, закрытыми для прочтения, в случае, когда абоненты могут пользоваться только открытыми линиями связи. Однако при этом сообщение пересылается три раза от одного абонента к другому, что является недостатком. Шифр Эль-Гамаля позволяет решить ту же задачу за одно пересылку данных, но объем передаваемого шифротекста в два раза превышает объем сообщения. Система RSA лишена подобных недостатков. Интересно то, что она базируется на другой односторонней функции, отличной от дискретного логарифма. Кроме того, здесь мы встретимся с еще одним изобретением современной криптографии - <i>односторонней функцией с «лазейкой»</i> (trapdoor function).</p>
<p>Эта система базируется на следующих двух фактах из теории чисел:</p>
<p>1) задача проверки числа на простоту является сравнительно легкой;</p>
<p>2) задача разложения чисел вида n = pq (p и q — простые числа) на множители является очень трудной, если мы знаем только n, а p и q — большие числа (это так называемая задача факторизации).</p>
<p>Пусть в нашей системе есть абоненты A, B, C, .... Каждый абонент выбирает случайно два больших простых числа P и Q. Затем он вычисляет число</p>
<p><img src="img/image95.png" height="31" width="109">              (2.28)</p>
<p>(Число N является открытой информацией, доступной другим абонентам.) После этого абонент вычисляет число <img src="img/image96.png" height="24" width="169"> и выбирает некоторое число <img src="img/image97.png" height="25" width="52">, взаимно простое с <img src="img/image98.png" height="19" width="16">, и по обобщенному алгоритму Евклида находит число c, такое, что</p>
<p><img src="img/image99.png" height="28" width="133">              (2.29)</p>
<p>Вся информация, связанная с абонентами и являющаяся их открытыми и секретными ключами, представлена в табл. 2.4.</p>
<p>Т а б л и ц а 2.4. Ключи пользователей в системе RSA</p>
<p><img src="img/image100.png" height="104" width="468"></p>
<p>Опишем протокол RSA. Пусть Алиса хочет передать сообщение m Бобу, причем сообщение m рассматривается как число, удовлетворяющее неравенству m < N<sub>B</sub> (далее индекс B указывает на то, что соответствующие параметры принадлежат Бобу).</p>
<p><b>Шаг 1.</b> Алиса шифрует сообщение по формуле</p>
<p><img src="img/image101.png" height="32" width="168">              (2.30)</p>
<p>используя открытые параметры Боба, и пересылает e по открытой линии.</p>
<p><b>Шаг 2.</b> Боб, получивший зашифрованное сообщение, вычисляет</p>
<p><img src="img/image102.png" height="32" width="174">              (2.31)</p>
<p><b>Утверждение 2.12.</b> <i>Для описанного протокола m' = m, т.е. абонент B получает исходящее от A сообщение.</i></p>
<p>Д о к а з а т е л ь с т в о. По построению протокола </p>
<p><img src="img/image103.png" height="36" width="311"></p>
<p>Равенство (2.29) означает, что для некоторого k </p>
<p><img src="img/image104.png" height="36" width="171"></p>
<p>Согласно утверждению 2.5</p>
<p><img src="img/image105.png" height="30" width="292"></p>
<p>где <img src="img/image106.png" height="24" width="33"> — функция Эйлера. Отсюда и из теоремы 2.8 следует </p>
<p><img src="img/image107.png" height="32" width="272"></p>
<br>
<p><b>Утверждение 2.13 (свойства протокола RSA)</b>.</p>
<p class=punkt>1)	<i>Протокол шифрует и дешифрует информацию корректно;</i></p>
<p class=punkt>2)	<i>злоумышленник, перехватывающий все сообщения и знающий всю открытую информацию, не сможет найти исходное сообщение при болъших P и Q.</i></p>
<p>Д о к а з а т е л ь с т в о. Первое свойство протокола следует из утверждения 2.12. Для доказательства второго свойства заметим, что злоумышленник знаeт только открытые параметры N и d. Для того чтобы найти c, он должeн знать значeниe <img src="img/image96.png" height="24" width="169">, а для этого, в свою очередь, ему требуется знать P и Q. Вообще говоря, он может найти P и Q, разложив N на множители, однако это трудная задача (см. пункт 2 в началe раздела). Отметим, что выбор больших случайных P и Q возможeн за приемлемое время, так как справедлив пункт 1.</p>
<p>Односторонняя функция <img src="img/image108.png" height="24" width="117">, примeняeмая в системе RSA, обладает так называeмой «лазейкой», позволяющей легко вычислить обратную функцию <img src="img/image109.png" height="21" width="134">, если известно разложение N на простые множители. (Действительно, легко вычислить <img src="img/image96.png" height="24" width="169">, а затем <img src="img/image110.png" height="23" width="119">.) Если P и Q нeизвeстны, то вычисление значeния обратной функции практически нeвозможно, а найти P и Q по N очень трудно, т.е. знаниe P и Q — это «лазейка» или «потайной ход»). Такие односторонние функции с лазейкой находят примeнeниe и в других разделах криптографии.</p>
<p>Отметим, что для схемы RSA важно, чтобы каждый абонeнт выбирал собствeнную пару простых чисел P и Q, т.е. все модули N<sub>A</sub>, N<sub>B</sub>, N<sub>C</sub>, ... должны быть различны (в противном случае один абонeнт мог бы читать зашифрованные сообщения, прeдназначeнныe для другого абонeнта). Однако этого нe требуется от второго открытого параметра <sub>d</sub>. Параметр <sub>d</sub> может быть одинаковым у всех абонeнтов. Часто рекомендуется выбирать d = 3 (при соответствующем выборе P и Q, см. [23]). Тогда шифрование выполняeтся максимально быстро, всего за два умножения.</p>
<p>П р и м е р 2.17. Допустим, Алиса хочет передать Бобу сообщение m =15. Пусть Боб выбрал следующие параметры:</p>
<p><img src="img/image111.png" height="30" width="299"></p>
<p>(3 взаимно просто с <img src="img/image112.png" height="22" width="47"> = 20). Найдем c<sub>B</sub> с помощью обобщенного алгоритма Евклида:  c<sub>B</sub> = 7</p>
<p>(проверим: 3 <span style='font-size:8.0pt;line-height:150%'>•</span> 7 mod 20 = 1). Кодируем m по формуле (2.30)</p>
<p><img src="img/image113.png" height="23" width="447"></p>
<p>Число 9 Алиса передает Бобу по открытому каналу связи. Только Боб знает c<sub>B</sub> = 7, поэтому он декодирует принятое сообщение, используя (2.31):</p>
<p><img src="img/image114.png" height="24" width="524"></p>
<p>Таким образом, Боб расшифровал сообщение Алисы.</p>
<p>Рассмотренная система невскрываема при больших P и Q, но обладает следующим недостатком: A передает сообщение B, используя открытую информацию абонента B (числа N<sub>B</sub> и d<sub>B</sub>). Злоумышленник не может читать сообщения, предназначенные для B, однако он может передать сообщение к B от имени A. Избежать этого можно, используя более сложные протоколы, например, следующий.</p>
<p>A хочет передать B сообщение m. Сначала A вычисляет число <img src="img/image115.png" height="23" width="138">. Злоумышленник не может этого сделать, так как С<sub>А</sub> секретно. Затем A вычисляет число <img src="img/image116.png" height="23" width="132"> и передает f к B. B получает f и вычисляет последовательно числа <img src="img/image117.png" height="26" width="108"><i>N<sub>B</sub></i> и <img src="img/image118.png" height="25" width="139">.</p>
<p>В результате абонент B получает сообщение <img src="img/image119.png" height="18" width="56">. Как и в исходной схеме RSA, злоумышленник не может прочитать переданное сообщение, но здесь, в отличие от RSA, он не может также послать сообщение от имени A (поскольку не знает секретного С<sub>А</sub> ).</p>
<p>Здесь мы встречаемся с новой ситуацией. B знает, что сообщение пришло от A, т.е. A как бы «подписал» его, зашифровав своим секретным С<sub>А</sub>. Это пример так называемой <i>электронной или цифровой подписи</i>. Она — одно из широко используемых на практике изобретений современной криптографии и будет систематически изучаться в главе 5. </p>
<br>
<a name=7 class="anchor"></a>
<h3>Задачи и упражнения</h3>
<p><b>2.1.</b>	Привести результат выражений 5, 16, 27, -4, -13, 3 + 8, 3 — 8,</p>
<p class=punkt>3 <span style='font-size:8.0pt;line-height:150%'>•</span> 8, 3 <span style='font-size:8.0pt;line-height:150%'>•</span> 8 <span style='font-size:8.0pt;line-height:150%'>•</span> 5:</p>
<p class=punkt>       а.	по модулю 10,</p>
<p class=punkt>       б.	по модулю 11.</p>
<p><a href="lec6.htm#2.1" class=punkt>См. ответ.</a></p>
<p><b>2.2.</b>	Вычислить, используя быстрые алгоритмы возведения в степень, 2<sup>8</sup> mod 10, 3<sup>7</sup> mod 10, 7<sup>19</sup> mod 100, 7<sup>57</sup> mod 100. </p>
<p><a href="lec6.htm#2.2" class=punkt>См. ответ.</a></p>
<p><b>2.3.</b>	Разложить на простые множители числа 108, 77, 65, 30, 159. </p>
<p><a href="lec6.htm#2.3" class=punkt>См. ответ.</a></p>
<p><b>2.4.</b>	Определить, какие из пар чисел (25, 12), (25, 15), (13, 39), (40, 27) взаимно просты. </p>
<p><a href="lec6.htm#2.4" class=punkt>См. ответ.</a></p>
<p><b>2.5.</b>	Найти значения функции Эйлера <img src="img/image120.png" height="21" width="16">(14), <img src="img/image120.png" height="21" width="16">(20).</p>
<p><a href="lec6.htm#2.5" class=punkt>См. ответ.</a></p>
<p><b>2.6.</b>	Используя свойства функции Эйлера, вычислить <img src="img/image120.png" height="21" width="16">(53), <img src="img/image120.png" height="21" width="16">(21), <img src="img/image120.png" height="21" width="16">(159). </p>
<p><a href="lec6.htm#2.6" class=punkt>См. ответ.</a></p>
<p><b>2.7.</b>	Используя теорему Ферма, вычислить 3<sup>13</sup> mod 13, 5<sup>22</sup> mod 11, 3<sup>17</sup> mod 5.</p>
<p><a href="lec6.htm#2.7" class=punkt>См. ответ.</a></p>
<p><b>2.8.</b>	Используя теорему Эйлера, вычислить 3<sup>9</sup> mod 20, 2<sup>14</sup> mod 21, 2<sup>107</sup> mod 159. </p>
<p><a href="lec6.htm#2.8" class=punkt>См. ответ.</a></p>
<p><b>2.9.</b>	С помощью алгоритма Евклида найти gcd(21,12), gcd(30,12), gcd(24, 40), gcd(33, 16). </p>
<p><a href="lec6.htm#2.9" class=punkt>См. ответ.</a></p>
<p><b>2.10.</b>	С помощью обобщенного алгоритма Евклида найти значения x и y в уравнениях</p>
<p><img src="img/image121.png" height="107" width="262"></p>
<p><a href="lec6.htm#2.10" class=punkt>См. ответ.</a></p>
<p><b>2.11.</b>	Вычислить 3<sup>-1</sup> mod 7, 5<sup>-1</sup> mod 8, 3<sup>-1</sup> mod 53, 10<sup>-1</sup> mod 53. </p>
<p><a href="lec6.htm#2.11" class=punkt>См. ответ.</a></p>
<p><b>2.12.</b>	Выписать все простые числа, меньшие 100. Какие из них соответствуют виду <i>p = 2q + 1</i>, где <i>q</i> также простое? </p>
<p><a href="lec6.htm#2.12" class=punkt>См. ответ.</a></p>
<p><b>2.13.</b>	Найти все допустимые варианты выбора параметра <i>g</i> в системе Диффи-Хеллмана при p = 11.</p>
<p><a href="lec6.htm#2.13" class=punkt>См. ответ.</a></p>
<p><b>2.14.</b>	Вычислить открытые ключи Y<sub>A</sub>, Y<sub>B</sub> и общий ключ Z<sub>AB</sub> для системы Диффи-Хеллмана с параметрами:</p><p><img src="img/image122.png" height="144" width="338"></p>
<p><a href="lec6.htm#2.14" class=punkt>См. ответ.</a></p>
<p><b>2.15.</b>	Для шифра Шамира с заданными параметрами p, c<sub>A</sub>, c<sub>B</sub> найти недостающие параметры и описать процесс передачи сообщения m от A к B: </p>
<p><img src="img/image123.png" height="151" width="334"></p>
<p><a href="lec6.htm#2.15" class=punkt>См. ответ.</a></p>
<p><b>2.16.</b>	Для шифра Эль-Гамаля с заданными параметрами p, g, c<sub>B</sub>, k найти недостающие параметры и описать процесс передачи сообщения m пользователю B:</p>
<p><img src="img/image124.png" height="140" width="323"></p>
<p><a href="lec6.htm#2.16" class=punkt>См. ответ.</a></p>
<p><b>2.17.</b>	В системе RSA с заданными параметрами P<sub>A</sub>, Q<sub>A</sub>, d<sub>A</sub> найти недостающие параметры и описать процесс передачи сообщения m пользователю A:	</p>
<p><img src="img/image125.png" height="140" width="333"></p>
<p><a href="lec6.htm#2.17" class=punkt>См. ответ.</a></p>
<p><b>2.18.</b>	Пользователю системы RSA с параметрами N = 187, d = 3 передано зашифрованное сообщение e = 100. Расшифровать это сообщение, взломав систему RSA пользователя.  </p>
<p><a href="lec6.htm#2.18" class=punkt>См. ответ.</a></p>
<p></p>
<p></p>

<br><br>
<!--конец-->
      
				

				</div>
			</div>
			
      </div>
    </div>
  </div>
	
	<!--Меню навигации по Темам -->	
	<div aria-label="..." class = "nav-menu">
	 <ul class="pager background-transition-slow">
		 <li title="Наверх" style = "margin-right:15px;	"><a class = "glyphicon glyphicon-menu-up page-scroll" href="#page-top"></a></li>
		 <li title="К предыдущей лекции"><a class = "glyphicon glyphicon-menu-left page-scroll" href="lec1.htm"></a></li>
		 <li title="В содержание"><a class = "glyphicon glyphicon-list-alt" href="lec_index.htm"></a></li>
		 <li title="К следующей лекции"><a class = "glyphicon glyphicon-menu-right page-scroll" href="lec3.htm"></a></li>
	 </ul>
	</div>
	<!---->
	
	</div>
  <!-- jQuery -->
  <script src="../lib/js/jquery.js"></script>

  <!-- Bootstrap Core JavaScript -->
  <script src="../lib/js/bootstrap.min.js"></script>

  <!-- Scrolling Nav JavaScript -->
  <script src="../lib/js/jquery.easing.min.js"></script>
  <script src="../lib/js/scrolling-nav.js"></script>

</body>

</html>
